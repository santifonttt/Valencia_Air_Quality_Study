---
title: "OBJETIVO 4"
author: "Sergio Ortiz"
date: "2025-05-22"
output:
  html_document: default
  pdf_document: default
editor_options:
  markdown:
    wrap: sentence
resource_files:
- estaciones_valencia.csv
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

## Introducci√≥n

En el marco del an√°lisis integral de la **calidad ambiental de la ciudad de Valencia**, este bloque de trabajo se centra en la **contribuci√≥n del parque edificatorio a las emisiones de CO‚ÇÇ** y en c√≥mo dicho comportamiento energ√©tico se relaciona con otros factores urbanos (contaminantes atmosf√©ricos, tr√°fico y condiciones meteorol√≥gicas).

### Objetivos espec√≠ficos del estudio

1.  **Depurar y enriquecer** la base de datos de certificados energ√©ticos para obtener indicadores clave, entre ellos:

    -   Intensidad de emisiones (kg CO‚ÇÇ / m¬≤¬∑a√±o)\
    -   Antig√ºedad de los edificios\
    -   Tipolog√≠a y uso predominante

2.  **Estudio preliminar de los c√≥digos postales**

3.  **Geocodificar** cada inmueble y **agruparlos por cl√∫steres** espaciales que permitan identificar patrones de emisiones a escala de barrio (centro hist√≥rico, zonas industriales, √°rea mar√≠tima, etc.).

4.  **Relacionar** los cl√∫steres edificatorios con:

    -   Niveles de contaminantes (NO‚ÇÇ, PM‚ÇÇ.‚ÇÖ‚Ä¶) registrados en las estaciones de calidad del aire.\
    -   **Tr√°fico** (intensidad media diaria) en la red principal.

5.  **Evaluar la influencia** de variables como uso, antig√ºedad o contexto urbano en las emisiones y en la calidad del aire local, con el fin de proponer estrategias de mitigaci√≥n y renovaci√≥n energ√©tica.

> Este documento aborda el **Paso 1 ‚Äì Limpieza y preprocesado** del CSV de certificados, dejando los datos listos para la geocodificaci√≥n y los an√°lisis posteriores.

Los datos que se han analizado provienen de la p√°gina web del [**IVACE**](https://gceedadesobertes.aven.es/dadesobertes/), se ha descargado los csv de los registros de los **Certificado de Eficiencia Energ√©ticos(CEE)** desde 2013 a 2024, posteriormente se han unido todos los archivos en uno solo y se ha procedido a la limpieza Y an√°lisis de los datos.

Preliminarmente, se hizo una limpieza de las zonas con sensores de contaminaci√≥n pero posterioremente se ha hecho otra selecci√≥n.
ras la limpieza de los datos se ha procedido a un escrapeado de los datos que se encuentran en catastro para obtener una base de datos m√°s completa para abordar este objetivo,

La web de Catastro no ha sido sencilla para obtener los datos, es una p√°gina web que no est√° optimizada, cada consulta requer√≠a de mucho tiempo, habiendo casos de casi 4 segundos, si se hubiera ejecutado una consulta por interacci√≥n hubiera durado d√≠as y tambi√©n hay que comentar la estricta seguridad y dificultad que tiene la p√°gina, a los pocos intentos detecta que es un proceso autom√°tico y bloquea la IP durante una semana y tienen activado la aparici√≥n de las cookies varias veces por entrada al portal, con caracter√≠sticas diferentes y pensamos que no salen al mismo tiempo para todas las referencia catastrales.

Para obtener la mayor√≠a de los datos se han usado solicitudes via URL indicando la referencia catastral y encontrando los numero que dispone cada localidad para usar este m√©todo, para solucionar el problema de lentitud se han utilizado procesos multiparalelizados, y el uso de proxies, la m√°quina virtual ha sido de gran ayuda porque nos ha permitido no tener nuestros ordenadores inutilizados durante el proceso.

Con ese m√©todo se consigu√≥ la mayoria de datos extras de las referencias catastrales, los restantes se han tenido que hacer usando la interfaz de la web, y la librer√≠a Selenium de Python y otras no se han podido obtener datos porque este identificador del inmueble estaba codificados de distinta manera, ya sea errores humanos, o por la inclusi√≥n de signos , letras o espacios, se intent√≥ corregirlos pero no tuvo muchos exito por no haber un patr√≥n.

Se quer√≠a geolocalizar cada vivienda por la direcci√≥n usando la API de Google Maps, pero no se ha podido realizar por el coste que tiene.Se han intentado numerosas t√©cnicas y no han tenido el √©xito que se deseaba:

```         
- API de R CatastRO: funcion√≥ con 6000k referencias pero nos bloque√≥ por exceso de solicitudes y era muy lenta. 
- Solicitudes masivas a la web de Catastro por archivos XML, devolv√≠a datos econ√≥micos y otros que no eran de importancia. 
- Scrapeo de apartado de informaci√≥n de parcelas, no consegu√≠mos sacar las coordenadas. 
```

Por √∫ltimo intento se pudo hacer con los shapefiles que dispone Catastro, aunque no se encontr√≥ de forma sencilla el contenido que se dispon√≠a ni como funcionaban, tras varias pruebas se han obtenido un 98% de las coordenadas e incluso el pol√≠gono , pero en esta situaci√≥n solo utilizaremos un punto para facilitar la geolocalizaci√≥n.
Se puede ver el archivo de Python que nos ha permitdo obtenerlo en la carpeta COORDENADAS REFERENCIAS, el restante de geolocalizaci√≥n se har√° via API Google Maps, debido a que ya no es gran cantidad.

```{r librerias}

# Carga de librer√≠as
library(tidyverse)   # readr, dplyr, ggplot2...
library(janitor)     # clean_names, tabyl
library(lubridate)   # manejo de fechas
library(stringr)     # expresiones regulares
library(sf)          # objetos espaciales (cuando geocodifiques)
library(dplyr)
library(stringr)
library(purrr)
library(readr)
library(dplyr)
library(ggplot2)
library(fastDummies)
library(FactoMineR)
library(factoextra)
library(leaflet)      # mapeo interactivo
library(geosphere)
library(ggplot2)


set.seed(123)   # reproducibilidad


```

# Estudio preliminar de los c√≥digos postales

## Preparado de datos

You can also embed plots, for example:

```{r , echo=FALSE}

ruta_archivo <- "data_final_Objetivo_4.csv"
data <- read.csv(ruta_archivo, stringsAsFactors = FALSE)


head(data)

```

```{r , echo=FALSE}

unique(data$USO_EDIFICIO)

```

Decidimos borrar la columna AlmEst.UsoRESID por tratarse de plazas de garaje, trasteros, no nos interesa para el estudio

```{r , echo=FALSE}

# Filtramos para quedarnos solo con los usos relevantes
data <- data %>%
  filter(USO_EDIFICIO != "AlmEst.UsoRESID")

```

```{r Agrupaci√≥n de categor√≠as}
library(dplyr)
library(stringr)

data <- data %>%
  mutate(
    uso_simplificado = case_when(
      str_to_lower(USO_EDIFICIO) %in% str_to_lower(c("VIVIENDA INDIVIDUAL", "VIVIENDA/S UNIFAMILIAR", "Residencial")) ~ "Vivienda",
      str_detect(str_to_lower(USO_EDIFICIO), "edificio de viviendas") ~ "Edificio de Viviendas",
      str_to_lower(USO_EDIFICIO) %in% str_to_lower(c("OFICINAS", "Oficinas")) ~ "Oficina",
      str_to_lower(USO_EDIFICIO) %in% str_to_lower(c("LOCAL COMERCIAL", "EDIFICIO COMERCIAL", "Comercial")) ~ "Comercial",
      str_to_lower(USO_EDIFICIO) == "hotel" ~ "Hotel",
      str_to_lower(USO_EDIFICIO) == "restaurante" ~ "Restaurante",
      str_to_lower(USO_EDIFICIO) %in% str_to_lower(c("centro de ense√±anza", "suelo sin edif.")) ~ "Centro de Ense√±anza",
      str_to_lower(USO_EDIFICIO) %in% str_to_lower(c("sanidad,benefic", "hospital")) ~ "Sanidad",
      str_to_lower(USO_EDIFICIO) == "religioso" ~ "Religioso",
      str_to_lower(USO_EDIFICIO) %in% str_to_lower(c("deportivo", "instalaciones deportivas")) ~ "Deportivo",
      str_to_lower(USO_EDIFICIO) %in% str_to_lower(c("cultural", "espect√°culos", "espect√É¬°culos")) ~ "Cultural",
      str_to_lower(USO_EDIFICIO) %in% str_to_lower(c("industrial", "almest.usoindus")) ~ "Industrial",
      str_to_lower(USO_EDIFICIO) == "agrario" ~ "Agrario",
      str_to_lower(USO_EDIFICIO) == "rdl 1/04 8.2.d" ~ "Puerto",
      TRUE ~ "Otro"
    )
  )
head(data)
```

```{r Eliminar filas}
# Elimina filas duplicadas por REFERENCIA_CATASTRAL + EMISIONES_CO2_VALOR
# o por DIRECCION + EMISIONES_CO2_VALOR
data <- data %>%
  distinct(REFERENCIA_CATASTRAL, EMISIONES_CO2_VALOR, .keep_all = TRUE) %>%
  distinct(DIRECCION, EMISIONES_CO2_VALOR, .keep_all = TRUE)
```

```{r Selecci√≥n de columnas}
# Seleccionar solo las columnas indicadas

data <- data %>%
  select(ANYO_CONSTRUCCION, uso_simplificado, CODIGO_POSTAL,
         EMISIONES_CO2_VALOR, SUPERFICIE_M2, parcela_catastral, lat, lon, EMISIONES_CO2_LETRA, MUNICIPIO_REFERENCIAS, USO_EDIFICIO)

```

# Limpieza de los datos

Vamos a representar cajas de bigotes por uso del edificio as√≠ podemos ver si hay an√≥malos.

```{r , Busqueda de an√≥malos}
# Funci√≥n para detectar outliers por USO_EDIFICIO y ordenarlos por anomal√≠a
detectar_outliers_por_uso <- function(data) {
  outliers <- data %>%
    group_by(uso_simplificado) %>%
    mutate(
      Q1 = quantile(EMISIONES_CO2_VALOR, 0.25, na.rm = TRUE),
      Q3 = quantile(EMISIONES_CO2_VALOR, 0.75, na.rm = TRUE),
      IQR = Q3 - Q1,
      limite_inferior = Q1 - 1.5 * IQR,
      limite_superior = Q3 + 1.5 * IQR
    ) %>%
    ungroup() %>%
    filter(EMISIONES_CO2_VALOR < limite_inferior | EMISIONES_CO2_VALOR > limite_superior) %>%
    mutate(
      anomal√≠a_inferior = abs(EMISIONES_CO2_VALOR - limite_inferior),
      anomal√≠a_superior = abs(EMISIONES_CO2_VALOR - limite_superior),
      anomal√≠a = ifelse(EMISIONES_CO2_VALOR < limite_inferior, anomal√≠a_inferior, anomal√≠a_superior)
    ) %>%
    arrange(uso_simplificado, desc(anomal√≠a))  # Orden dentro de cada grupo
  
  print("Outliers por uso_simplificado ordenados de mayor a menor anomal√≠a:")
  print(outliers %>% select(uso_simplificado, EMISIONES_CO2_VALOR, anomal√≠a, everything()))
  
  return(outliers)
 
} 
  
  
generar_boxplot_por_uso <- function(data) {
  ggplot(data, aes(x = uso_simplificado, y = EMISIONES_CO2_VALOR, fill = uso_simplificado)) +
    geom_boxplot(outlier.color = "red", outlier.shape = 8) +
    labs(
      title = "Boxplot de emisiones de CO‚ÇÇ por tipo de uso del edificio",
      x = "Uso del edificio",
      y = "Emisiones de CO‚ÇÇ (kg/m¬≤¬∑a√±o)"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.position = "none"
    ) +
    scale_fill_brewer(palette = "Set3")



}

# Aplicar la funci√≥n a los datos
outliers_por_uso <- detectar_outliers_por_uso(data)

# Generar boxplot original (con outliers)

generar_boxplot_por_uso(data)
```

Los an√≥malos de ALMEST.UsoINDUS parece que corresponden a las cochera de EMT que se encuentran al lado de la UPV, tiene explicaci√≥n dicha contaminaci√≥n.
El centro de ense√±anza no es muy an√≥nalo, es un centro con muchas plantas y podria tener sentido esas emisiones.
El m√°s distanciado de Comercial se trata de un parking, se puede justificar sus emisiones por la cantidad de coches diarios y el segundo de un restaurante.
En cultural el que m√°s se distancia del resto es una biblioteca de grandes dimensiones.
En edificio Comercial, hay un centro de est√©tica y una lavander√≠a, parece muy sobredimensionada las emisiones de CO2, se decide eliminar.
El siguiente se trata de un centro comercial con parking, no es an√≥malo.
Los bloques de vivienda m√°s an√≥nalos se eliminan, tienen emisiones de CO2 muy elevadas.
En instalaciones deportivas hay an√≥malos muy extremos, Se elimina el primero por estar muy alejado al resto.
En cuanto a Oficina , las 3 primeras tienen emisiones muy elevadas, se eliminan.
Vivienda individual, se eliminan las 13 primeros por tener una anomal√≠a muy elevada.

```{r eLIMINAR AN√ìMALOS}

filas_a_eliminar <- data.frame(
  USO_EDIFICIO = rep("VIVIENDA INDIVIDUAL", 12),
  EMISIONES_CO2_VALOR = c(783, 783, 576, 494, 461, 365, 334, 332, 328, 315, 296, 288),
  SUPERFICIE_M2 = c(728.000, 728.000, 521.000, 439.000, 406.000, 310.000, 279.000, 277.000, 273.000, 260.000, 241.000, 233.000),
  ANYO_CONSTRUCCION = c(1973, 1955, 1970, 1931, 1997, 1960, 1966, 1981, 1960, 1966, 1955, 1890),
  CODIGO_POSTAL = c(46026, 46006, 46024, 46006, 46007, 46024, 46023, 46012, 46900, 46017, 46019, 46001),
  parcela_catastral = c(
    "6202901YJ2760A", "5714130YJ2751F", "9312408YJ2791C", "6016403YJ2761E", "4610805YJ2741B",
    "9505401YJ2790F", "8316420YJ2781E", "0800701YJ3600B", "7989803YJ1678N", "4697202YJ2649H",
    "5648405YJ2754H", "5728309YJ2752H"
  ),
  lat = c(
    39.45331, 39.46096, 39.46737, 39.46279, 39.45825,
    39.46697, 39.46845, 39.52726, 39.46618, 39.44596,
    39.49286, 39.47357
  ),
  lon = c(
    -0.3721880, -0.3771560, -0.3357290, -0.3740960, -0.3896420,
    -0.3324780, -0.3464060, -0.4334920, -0.3505950, -0.3906090,
    -0.3769920, -0.3768470
  )
)

library(dplyr)

data <- anti_join(data, filas_a_eliminar, by = c(
  "USO_EDIFICIO", "EMISIONES_CO2_VALOR", "SUPERFICIE_M2",
  "ANYO_CONSTRUCCION", "CODIGO_POSTAL", "parcela_catastral",
  "lat", "lon"
))

# Correcci√≥n de filas 
# 1. Crear el data.frame con las correcciones
coord_corregidas <- data.frame(
  parcela_catastral = c("000720100YJ16C", "001430800YJ06F", "001431900YJ06F", 
                        "0036613YJ2703N", "1449317YJ3514G", "1776551YJ2717N"),
  lat_nueva = c(39.401366901191494, 39.41586484113674, 39.41747731892181, 
                39.482406786374035, 39.48233225977674, 39.51680882117547),
  lon_nueva = c(-0.5415714942790637, -0.5991076441776843, -0.5985237400117808, 
                -0.4423017452644876, -0.4422910164289535, -0.4216401894407453)
)

# 2. Hacer el join y reemplazar solo las coordenadas que coincidan
data_parcelas<- data %>%
  left_join(coord_corregidas, by = "parcela_catastral") %>%
  mutate(
    lat = ifelse(!is.na(lat_nueva), lat_nueva, lat),
    lon = ifelse(!is.na(lon_nueva), lon_nueva, lon)
  ) %>%
  select(-lat_nueva, -lon_nueva)

#Se observa errores con algunas referecias as√≠ que se eliminan 
# Crear el vector de referencias a eliminar
referencias_a_eliminar <- c(
  "46246A03300153", "5481413YJ2658A", "6462907YJ2766A", "46246A02700129", "46246A02500187",
  "46246A03001172", "4155617YJ2745E", "46246A03000417", "7173219YJ1677S", "46246A02600336",
  "5574209YJ2657S", "46246A03001226", "7728122YJ2772H", "5912335YJ2751B", "6212322YJ2761C",
  "46246A02600652", "46246A03001304", "6520819YJ2762B", "46246A03100108", "4723124YJ1742S",
  "5583104YJ1758S", "2428811YJ2722N", "46246A02600539", "6519422YJ2761H", "46246A02700106",
  "4045808YJ2644N", "9826603YJ2792F", "46246A03001029", "46246A00900243", "8485807YJ1688N",
  "5738220YJ2753H", "46246A02900017", "2431707YJ2723S", "4523104YJ1742S", "46246A03000069",
  "7932211YJ2773D", "7913208YJ1871S", "46246A03000108", "7365530YJ1676N", "5773116YJ1657S",
  "002040900YJ06F", "46246A04700031", "5913108YJ2751D", "5482503YJ1658S", "5944120YJ2754D",
  "46246A03200101", "46246A03200160", "5247418YJ2754G", "7624409YJ2772D", "9307111YJ2790E",
  "7612310YJ1871S", "46246A02600558", "46246A03001362", "46246A03001105", "5292113YJ1759S",
  "6943313YJ2764D", "6682110YJ1768S", "4338605YJ2743G", "6017411YJ2761E", "46246A02600472",
  "5571365YJ2657S", "46246A03200170", "46246A04800018", "9622315YJ2792D", "4655810YJ2745F",
  "7975108YJ1677N", "5384708YJ1758S", "5586718YJ1758N", "46246A04800152", "5172805YJ2657S",
  "46246A04900042", "46246A03000901", "2068514YJ2726N", "46246A03000794", "9940302YJ2794B",
  "9626418YJ2792F", "46246A04600140", "46246A03200074", "7612308YJ1871S", "46246A03001411",
  "8223722YJ2782C", "46246A03001317", "5583108YJ1758S", "8390608YJ1689S", "5582907YJ1758S",
  "46246A00100105", "5841220YJ2754B", "9937621YJ2793F", "2877916YJ2627N", "7520614YJ2772B",
  "46246A02600453", "46246A03001107", "46246A03200158", "46246A02900100", "2263112YJ2726S",
  "46246A00200424", "46246A05200099", "46246A02900107", "46246A02600470", "9415316YJ2791E",
  "3645213YJ2634N", "4220318YJ2742A"
)

# Filtrar las parcelas que NO est√°n en la lista
data_parcelas <- data_parcelas %>%
  filter(!parcela_catastral %in% referencias_a_eliminar)

```

```{r an√°lisis de distribuci√≥n}

library(e1071)

resumen_emisiones <- data %>%
  summarise(
    n              = sum(!is.na(EMISIONES_CO2_VALOR)),
    media          = mean(EMISIONES_CO2_VALOR, na.rm = TRUE),
    mediana        = median(EMISIONES_CO2_VALOR, na.rm = TRUE),
    desviacion     = sd(EMISIONES_CO2_VALOR, na.rm = TRUE),
    minimo         = min(EMISIONES_CO2_VALOR, na.rm = TRUE),
    Q1             = quantile(EMISIONES_CO2_VALOR, 0.25, na.rm = TRUE),
    Q3             = quantile(EMISIONES_CO2_VALOR, 0.75, na.rm = TRUE),
    maximo         = max(EMISIONES_CO2_VALOR, na.rm = TRUE),
    asimetria      = skewness(EMISIONES_CO2_VALOR, na.rm = TRUE),
    curtosis       = kurtosis(EMISIONES_CO2_VALOR, na.rm = TRUE)
  )

print(resumen_emisiones)

library(ggplot2)

ggplot(data, aes(x = EMISIONES_CO2_VALOR)) +
  geom_histogram(bins = 50, fill = "#1f77b4", color = "black", alpha = 0.7) +
  labs(
    title = "Distribuci√≥n de las Emisiones de CO‚ÇÇ",
    x = "Emisiones de CO‚ÇÇ (kg/m¬≤¬∑a√±o)",
    y = "Frecuencia"
  ) +
  theme_minimal()


```

La media y mediana se encuentran muy pr√≥ximas, nos ofrece una dispersi√≥n moderada respecto a la media.
Si hablamos de la as√≠metr√≠a nos ofrece la informaci√≥n que est√° muy sesgada a la deracha y tiene alta curtosis, lo que indica que hay una gran cantidad de valores extremos.

Se observa la fila que emite 2035 kg/m¬≤¬∑a√±o,

```{r , echo=FALSE}
data %>%
  filter(EMISIONES_CO2_VALOR == 2035)

```

Se elimina dicho inmueble, se trata de un bar y parece muchas emisiones aunque sea viejo y con mala eficiencia energ√©tica.

```{r , echo=FALSE}
# Eliminar el inmueble con 2035 kg/m¬≤¬∑a√±o
data <- data %>%
  filter(!(ANYO_CONSTRUCCION     == 1993 &
           USO_EDIFICIO          == "LOCAL COMERCIAL" &
           CODIGO_POSTAL         == 46470 &
           EMISIONES_CO2_VALOR   == 2035 &
           SUPERFICIE_M2         == 1540 &
           parcela_catastral     == "3754704YJ2635S" &
           lat                   == 39.49776 &
           lon                   == -0.399536))
```

```{r , echo=FALSE}
library(e1071)

resumen_emisiones <- data %>%
  summarise(
    n              = sum(!is.na(EMISIONES_CO2_VALOR)),
    media          = mean(EMISIONES_CO2_VALOR, na.rm = TRUE),
    mediana        = median(EMISIONES_CO2_VALOR, na.rm = TRUE),
    desviacion     = sd(EMISIONES_CO2_VALOR, na.rm = TRUE),
    minimo         = min(EMISIONES_CO2_VALOR, na.rm = TRUE),
    Q1             = quantile(EMISIONES_CO2_VALOR, 0.25, na.rm = TRUE),
    Q3             = quantile(EMISIONES_CO2_VALOR, 0.75, na.rm = TRUE),
    maximo         = max(EMISIONES_CO2_VALOR, na.rm = TRUE),
    asimetria      = skewness(EMISIONES_CO2_VALOR, na.rm = TRUE),
    curtosis       = kurtosis(EMISIONES_CO2_VALOR, na.rm = TRUE)
  )
print(resumen_emisiones)
```

```{r , echo=FALSE}
data %>%
  filter(EMISIONES_CO2_VALOR == 1185)

```

A pesar de ser una vivienda vieja del Carmen sigue siendo muy por encima de la media, se decide eliminar.

```{r , echo=FALSE}
data <- data %>%
  filter(!(ANYO_CONSTRUCCION   == 1800 &
           USO_EDIFICIO        == "EDIFICIO DE VIVIENDAS (BLOQUE COMPLETO)" &
           CODIGO_POSTAL       == 46003 &
           EMISIONES_CO2_VALOR == 1185 &
           SUPERFICIE_M2       == 1240 &
           parcela_catastral   == "5632313YJ2753D" &
           lat                 == 39.4778 &
           lon                 == -0.377418))
```

```{r , echo=FALSE}
library(e1071)

resumen_emisiones <- data %>%
  summarise(
    n              = sum(!is.na(EMISIONES_CO2_VALOR)),
    media          = mean(EMISIONES_CO2_VALOR, na.rm = TRUE),
    mediana        = median(EMISIONES_CO2_VALOR, na.rm = TRUE),
    desviacion     = sd(EMISIONES_CO2_VALOR, na.rm = TRUE),
    minimo         = min(EMISIONES_CO2_VALOR, na.rm = TRUE),
    Q1             = quantile(EMISIONES_CO2_VALOR, 0.25, na.rm = TRUE),
    Q3             = quantile(EMISIONES_CO2_VALOR, 0.75, na.rm = TRUE),
    maximo         = max(EMISIONES_CO2_VALOR, na.rm = TRUE),
    asimetria      = skewness(EMISIONES_CO2_VALOR, na.rm = TRUE),
    curtosis       = kurtosis(EMISIONES_CO2_VALOR, na.rm = TRUE)
  )
print(resumen_emisiones)
```

Para hacer clustering que es el objetivo principal de este objetivo no se necesita tener datos normalizados.
decidimos no eliminar m√°s datos.

## Estudio Preliminar C√≥digos Postales

Queremos ver la cantidad de certificados que hay por c√≥digo postal y la letra de emisiones de CO2, para ver si hay alg√∫n patr√≥n.

```{r , echo=FALSE}
library(dplyr)
library(tidyr)

# Crear tabla de frecuencias por c√≥digo postal, municipio y letra de emisiones
tabla_frecuencias <- data %>%
  group_by(CODIGO_POSTAL, EMISIONES_CO2_LETRA) %>%
  summarise(Frecuencia = n(), .groups = "drop") %>%
  arrange(CODIGO_POSTAL, EMISIONES_CO2_LETRA)

# Pivotar: las letras A‚ÄìG se convierten en columnas
tabla_frecuencias <- data %>%
  filter(!is.na(EMISIONES_CO2_LETRA), EMISIONES_CO2_LETRA != "") %>%
  group_by(CODIGO_POSTAL, MUNICIPIO_REFERENCIAS, EMISIONES_CO2_LETRA) %>%
  summarise(Frecuencia = n(), .groups = "drop") %>%
  arrange(CODIGO_POSTAL, EMISIONES_CO2_LETRA)


tabla_frecuencias_pivotada <- tabla_frecuencias %>%
  pivot_wider(
    names_from = EMISIONES_CO2_LETRA,
    values_from = Frecuencia,
    values_fill = list(Frecuencia = 0)
  ) %>%
  mutate(
    Suma_Total = rowSums(across(where(is.numeric) & !c(CODIGO_POSTAL)))
  )


# Ver resultado
print(tabla_frecuencias_pivotada)
```
```{r}
# Agrupar por c√≥digo postal y letra, y calcular la media
tabla_medias <- data %>%
  filter(!is.na(EMISIONES_CO2_LETRA) & EMISIONES_CO2_LETRA != "") %>%
  group_by(CODIGO_POSTAL, EMISIONES_CO2_LETRA) %>%
  summarise(Media_Emisiones_CO2 = mean(EMISIONES_CO2_VALOR, na.rm = TRUE), .groups = "drop")

# Pivotar y renombrar
tabla_medias_pivotada <- tabla_medias %>%
  pivot_wider(
    names_from = EMISIONES_CO2_LETRA,
    values_from = Media_Emisiones_CO2,
    values_fill = list(Media_Emisiones_CO2 = NA)
  )

# Mostrar tabla
print(tabla_medias_pivotada)

```


# Gr√°fico de barras apiladas de las emisiones de CO2

```{r}

library(dplyr)
library(tidyr)
library(ggplot2)

# Definir los colores por categor√≠a energ√©tica
colores_categorias <- c(
  "A" = "#4CAF50",     # Verde oscuro
  "B" = "#8BC34A",     # Verde claro
  "C" = "#CDDC39",     # Amarillo verdoso
  "D" = "#FFEB3B",     # Amarillo
  "E" = "#FFC107",     # Naranja claro
  "F" = "#FF5722",     # Naranja oscuro
  "G" = "#F44336"      # Rojo
)

# 1. Calcular suma total por fila (excluyendo columnas no num√©ricas)
tabla_frecuencias_ordenada <- tabla_frecuencias_pivotada %>%
  mutate(Suma_Total = rowSums(across(where(is.numeric) & !c(CODIGO_POSTAL)), na.rm = TRUE)) %>%
  group_by(CODIGO_POSTAL) %>%
  arrange(CODIGO_POSTAL, desc(Suma_Total)) %>%
  ungroup()

# 2. Convertir a formato largo para ggplot (excluyendo Suma_Total)
tabla_frecuencias_pivotada_long <- tabla_frecuencias_ordenada %>%
  select(-Suma_Total) %>%
  pivot_longer(
    cols = -c(CODIGO_POSTAL, MUNICIPIO_REFERENCIAS),
    names_to = "Categoria",
    values_to = "Frecuencia"
  )

# 3. Crear gr√°fico por municipio
municipios <- unique(tabla_frecuencias_pivotada_long$MUNICIPIO_REFERENCIAS)
graficos <- list()

for (mun in municipios) {
  datos_municipio <- tabla_frecuencias_pivotada_long %>%
    filter(MUNICIPIO_REFERENCIAS == mun) %>%
    mutate(CODIGO_POSTAL = factor(CODIGO_POSTAL, levels = unique(CODIGO_POSTAL)))
  
  grafico <- ggplot(datos_municipio, aes(x = CODIGO_POSTAL, y = Frecuencia, fill = Categoria)) +
    geom_bar(stat = "identity") +
    scale_fill_manual(values = colores_categorias) +
    labs(
      x = "C√≥digo Postal",
      y = "Frecuencia",
      title = paste("Distribuci√≥n de letras energ√©ticas en", mun)
    ) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))
  
  nombre_variable <- paste0(gsub(" ", "_", tolower(mun)), "_grafico_letras")
  assign(nombre_variable, grafico, envir = .GlobalEnv)
  graficos[[nombre_variable]] <- grafico
}


```

```{r}
for (grafico in graficos) {
  print(grafico)
}
```

Se puede observar que en todos los barrios siguen una proporci√≥n parecida en las calificaciones de las emisiones, siendo Valencia la ciudad con m√°s certificados energ√©ticos realizados.
Aunque est√©n incentivando la mejora de eficiencia energ√©tica y la reducci√≥n de la huella de carbono, se puede ver que las viviendas mejores califcadas a√∫n siguen siendo pocas.

# Tabla de medias de emisiones de CO2

```{r , echo=FALSE}
# Calcular la media de emisiones de CO‚ÇÇ por c√≥digo postal
# Calcular la media de emisiones de CO2 por c√≥digo postal y municipio
media_emisiones_co2 <- data %>%
  filter(EMISIONES_CO2_VALOR > 0) %>%
  group_by(CODIGO_POSTAL) %>%
  summarise(Media_Emisiones_CO2 = mean(EMISIONES_CO2_VALOR, na.rm = TRUE), .groups = "drop")

# Se a√±ade el municipio a la tabla de medias de emisiones de CO2


# Calcular la media corregida SOLO para Mislata (46920)
media_mislata_valor <- data %>%
  filter(CODIGO_POSTAL == "46920", !is.na(EMISIONES_CO2_VALOR), EMISIONES_CO2_VALOR > 0) %>%
  summarise(Media_CO2 = mean(EMISIONES_CO2_VALOR, na.rm = TRUE)) %>%
  pull(Media_CO2)

# Sustituir el valor de media en la tabla general media_emisiones_co2
media_emisiones_co2 <- media_emisiones_co2 %>%
  mutate(
    Media_Emisiones_CO2 = if_else(CODIGO_POSTAL == "46920", media_mislata_valor, Media_Emisiones_CO2)
  )
# Calcular la media corregida SOLO para Sedavi (46910)
media_mislata_valor <- data %>%
  filter(CODIGO_POSTAL == "46910", !is.na(EMISIONES_CO2_VALOR), EMISIONES_CO2_VALOR > 0) %>%
  summarise(Media_CO2 = mean(EMISIONES_CO2_VALOR, na.rm = TRUE)) %>%
  pull(Media_CO2)

# Sustituir el valor de media en la tabla general media_emisiones_co2
media_emisiones_co2 <- media_emisiones_co2 %>%
  mutate(
    Media_Emisiones_CO2 = if_else(CODIGO_POSTAL == "46910", media_mislata_valor, Media_Emisiones_CO2)
  )

#Se asigna letra a cada media 
media_emisiones_co2 <- media_emisiones_co2 %>%
  mutate(EMISIONES_CO2_LETRA = case_when(
    Media_Emisiones_CO2 <= 8 ~ "A",
    Media_Emisiones_CO2 > 8 & Media_Emisiones_CO2 <= 12 ~ "B",
    Media_Emisiones_CO2 > 12 & Media_Emisiones_CO2 <= 19 ~ "C",
    Media_Emisiones_CO2 > 19 & Media_Emisiones_CO2 <= 29 ~ "D",
    Media_Emisiones_CO2 > 29 & Media_Emisiones_CO2 <= 40 ~ "E",
    Media_Emisiones_CO2 > 40 & Media_Emisiones_CO2 <= 55 ~ "F",
    Media_Emisiones_CO2 > 55 ~ "G"
  ))
media_emisiones_co2
# Convertir las filas de EMISIONES_CO2_LETRA en columnas (pivotar)

tabla_medias_pivotada <- media_emisiones_co2 %>%
  pivot_wider(
    names_from = EMISIONES_CO2_LETRA,  # Convertir las letras en columnas
    values_from = Media_Emisiones_CO2,  # Los valores ser√°n las medias de emisiones CO2
    values_fill = list(Media_Emisiones_CO2 = NA)  # Rellenar con NA en caso de valores faltantes
    
  )
```

# Tabla frecuencia uso_simplificado

```{r , echo=FALSE}
tabla_uso_edificio <- data %>%
  group_by(CODIGO_POSTAL, uso_simplificado) %>%
  summarise(Frecuencia = n(), .groups = "drop") %>%
  arrange(CODIGO_POSTAL, desc(Frecuencia))
tabla_uso_edificio_pivotada <- tabla_uso_edificio %>%
  pivot_wider(
    names_from = uso_simplificado,
    values_from = Frecuencia,
    values_fill = list(Frecuencia = 0)
  )
tabla_uso_edificio_pivotada <- tabla_uso_edificio_pivotada %>%
  mutate(Total_Usos = rowSums(select(., -CODIGO_POSTAL), na.rm = TRUE))

# Suponiendo que sabes que las columnas de uso son del tipo character y num√©ricas
usos_cols <- setdiff(names(tabla_uso_edificio_pivotada), c("CODIGO_POSTAL", "Total_Usos"))

tabla_uso_edificio_pivotada <- tabla_uso_edificio_pivotada %>%
  rowwise() %>%
  mutate(
    Uso_Dominante = usos_cols[which.max(c_across(all_of(usos_cols)))]
  ) %>%
  ungroup()

```

```{r , echo=FALSE}
library(sf)
library(ggplot2)
library(dplyr)

# Cargar el GeoJSON del mapa
codigos_postales_mapa <- st_read("mapa_valencia_ccpp.geojson")

# Vista previa r√°pida del mapa
ggplot(codigos_postales_mapa) 
  geom_sf(fill = "lightblue", color = "black") +
  theme_minimal()
```

```{r , echo=FALSE}
# Se comprueba los valores del shapefile
names(codigos_postales_mapa)
codigos_postales_mapa <- codigos_postales_mapa %>%
  rename(CODIGO_POSTAL = COD_POSTAL)

# 1. ¬øTiene columnas?
names(tabla_uso_edificio_pivotada)

# 2. ¬øTiene filas?
names(tabla_medias_pivotada)

```

```{r , echo=FALSE}
codigos_postales_mapa$CODIGO_POSTAL <- as.character(codigos_postales_mapa$CODIGO_POSTAL)
media_emisiones_co2$CODIGO_POSTAL <- as.character(media_emisiones_co2$CODIGO_POSTAL)
tabla_frecuencias_pivotada$CODIGO_POSTAL <- as.character(tabla_frecuencias_pivotada$CODIGO_POSTAL)

tabla_medias_pivotada <- tabla_medias_pivotada %>%
  mutate(across(any_of(c("A", "B", "C", "D", "E", "F", "G")), as.numeric))


```

```{r , echo=FALSE}
# fILTRAMOS DATOS PARA C√ìDIGOS POSTALES 
codigos_postales_filtrados <- codigos_postales_mapa %>%
  filter(CODIGO_POSTAL %in% media_emisiones_co2$CODIGO_POSTAL)
names(codigos_postales_filtrados)
names(media_emisiones_co2)
names(tabla_frecuencias_pivotada)
names(tabla_medias_pivotada)

# Asegura que todos usan CODIGO_POSTAL como character
codigos_postales_filtrados$CODIGO_POSTAL <- as.character(codigos_postales_filtrados$CODIGO_POSTAL)
media_emisiones_co2$CODIGO_POSTAL        <- as.character(media_emisiones_co2$CODIGO_POSTAL)
tabla_frecuencias_pivotada$CODIGO_POSTAL <- as.character(tabla_frecuencias_pivotada$CODIGO_POSTAL)
tabla_medias_pivotada$CODIGO_POSTAL      <- as.character(tabla_medias_pivotada$CODIGO_POSTAL)
tabla_uso_edificio_pivotada$CODIGO_POSTAL <- as.character(tabla_uso_edificio_pivotada$CODIGO_POSTAL)

codigos_postales_mapa_final <- codigos_postales_filtrados %>%
  left_join(media_emisiones_co2,        by = "CODIGO_POSTAL") %>%
  left_join(tabla_frecuencias_pivotada, by = "CODIGO_POSTAL") %>%
  left_join(tabla_medias_pivotada,      by = "CODIGO_POSTAL") %>%
  left_join(tabla_uso_edificio_pivotada, by = "CODIGO_POSTAL")



```

```{r , echo=FALSE}
crear_grafico_tarta <- function(tabla_frecuencias, tabla_medias, cod_postal, colores_categorias) {
  library(dplyr)
  library(tidyr)
  library(ggplot2)

  # Filtrar por c√≥digo postal
  df_frecuencias <- tabla_frecuencias %>% filter(CODIGO_POSTAL == cod_postal)
  df_medias <- tabla_medias %>% filter(CODIGO_POSTAL == cod_postal)

  if (nrow(df_frecuencias) == 0 | nrow(df_medias) == 0) {
    stop("El c√≥digo postal especificado no se encuentra en los datos.")
  }

  # Excluir columnas no deseadas si existen
  cols_excluir <- intersect(c("CODIGO_POSTAL", "MUNICIPIO", "Suma_Total", "NA"), names(df_frecuencias))
  df_frecuencias_long <- df_frecuencias %>%
    select(-all_of(cols_excluir)) %>%
    pivot_longer(cols = where(is.numeric), names_to = "Categoria", values_to = "Cantidad")

  cols_excluir2 <- intersect(c("CODIGO_POSTAL", "MUNICIPIO", "Suma_Total", "NA"), names(df_medias))
  df_medias_long <- df_medias %>%
    select(-all_of(cols_excluir2)) %>%
    pivot_longer(cols = where(is.numeric), names_to = "Categoria", values_to = "Media_CO2")

  # Unir frecuencias y medias, eliminar letras no definidas
  df_final <- left_join(df_frecuencias_long, df_medias_long, by = "Categoria") %>%
    filter(Categoria %in% names(colores_categorias)) %>%
    mutate(Porcentaje = (Cantidad / sum(Cantidad, na.rm = TRUE)) * 100)

  # Crear gr√°fico de tarta
  grafico <- ggplot(df_final, aes(x = "", y = Cantidad, fill = Categoria)) +
    geom_bar(stat = "identity", width = 1, color = "black") +
    coord_polar("y", start = 0) +
    theme_void() +
    scale_fill_manual(values = colores_categorias) +
    labs(
      title = paste("Distribuci√≥n de Certificados en", cod_postal),
      fill = "Categor√≠a"
    )

  print(grafico)

  # Devolver tabla resumen
  df_final %>%
    select(Categoria, Cantidad, Media_CO2, Porcentaje)
}

```

# Ejemplo de popup

```{r , echo=FALSE}
crear_grafico_tarta(
  tabla_frecuencias = tabla_frecuencias_pivotada,
  tabla_medias = tabla_medias_pivotada,
  cod_postal = "46920",
  colores_categorias = colores_categorias
)
```

```{r , echo=FALSE}
# Crear gr√°fico usos
crear_grafico_usos <- function(tabla_usos, cod_postal) {
  library(dplyr)
  library(tidyr)
  library(ggplot2)
  

  # Filtrar la fila del c√≥digo postal
  df_usos <- tabla_usos %>% filter(CODIGO_POSTAL == cod_postal)

  if (nrow(df_usos) == 0) {
    stop("El c√≥digo postal especificado no se encuentra en la tabla de usos.")
  }

  # Eliminar columnas no deseadas (CODIGO_POSTAL, MUNICIPIO si existe, Total_Usos si existe)
  cols_excluir <- intersect(c("CODIGO_POSTAL", "MUNICIPIO", "Total_Usos"), names(df_usos))

  # Convertir a formato largo
  df_usos_long <- df_usos %>%
  select(where(is.numeric)) %>%
  pivot_longer(cols = everything(), names_to = "Uso", values_to = "Cantidad")


  # Calcular porcentajes
  total_usos <- sum(df_usos_long$Cantidad, na.rm = TRUE)
  df_usos_long <- df_usos_long %>%
    mutate(Porcentaje = (Cantidad / total_usos) * 100)

  # Crear gr√°fico de tarta
  grafico <- ggplot(df_usos_long, aes(x = "", y = Cantidad, fill = Uso)) +
    geom_bar(stat = "identity", width = 1, color = "black") +
    coord_polar("y", start = 0) +
    theme_void() +
    labs(
      title = paste("Distribuci√≥n de Usos en", cod_postal),
      fill = "Uso del Edificio"
    )

  print(grafico)

  # Devolver tabla resumen
  return(df_usos_long %>%
           arrange(desc(Porcentaje)) %>%
           select(Uso, Cantidad, Porcentaje))
}
```

```{r , echo=FALSE}
# Crear gr√°fico de usos para el c√≥digo postal 46001
crear_grafico_usos(
  tabla_usos = tabla_uso_edificio_pivotada,
  cod_postal = "46001"
)

names(codigos_postales_mapa_final)
# Creamos una carpeta donde guardar los CSV si no existe
if (!dir.exists("data_app_shiny")) {
  dir.create("data_app_shiny")
}

# Exportar las tablas como CSV
write.csv(media_emisiones_co2, "media_emisiones_co2.csv", row.names = FALSE)
write.csv(tabla_frecuencias_pivotada, "tabla_frecuencias_pivotada.csv", row.names = FALSE)
write.csv(tabla_medias_pivotada, "tabla_medias_pivotada.csv", row.names = FALSE)
write.csv(tabla_uso_edificio_pivotada, "tabla_uso_edificio_pivotada.csv", row.names = FALSE)


```

# Mapa intecractivo de emisiones de CO2

```{r , echo=FALSE}
library(shiny)
library(leaflet)
library(dplyr)
library(tidyr)
library(ggplot2)
library(sf)
codigos_postales_mapa_final$EMISIONES_CO2_LETRA <- as.character(codigos_postales_mapa_final$EMISIONES_CO2_LETRA)

# --- Colores letras A-G ---
colores_categorias <- c(
  
  "D" = "#FFEB3B",     # Amarillo
  "E" = "#FFC107",     # Naranja claro
  "F" = "#FF5722",     # Naranja oscuro
  "G" = "#F44336"      # Rojo
)

# --- Emoji para cada uso ---
asignar_emoji_uso <- function(uso) {
  case_when(
    uso == "Vivienda" ~ "üè†",
    uso == "Edificio de Viviendas" ~ "üè¢",
    uso == "Oficina" ~ "üè¢",
    uso == "Industrial" ~ "üè≠",
    uso == "Centro de Ense√±anza" ~ "üè´",
    uso == "Hotel" ~ "üè®",
    uso == "Comercial" ~ "üè¨",
    uso == "Sanidad" ~ "üè•",
    uso == "Restaurante" ~ "üçΩÔ∏è",
    uso == "Religioso" ~ "‚õ™",
    uso == "Deportivo" ~ "üèüÔ∏è",
    uso == "Puerto" ~ "‚öì",
    uso == "Agrario" ~ "üåæ",
    TRUE ~ "üì¶"
  )
}

# --- Crear gr√°fico de tarta de letras energ√©ticas ---
crear_grafico_tarta <- function(tabla_frecuencias, tabla_medias, cod_postal, colores_categorias) {
  df_frecuencias <- tabla_frecuencias %>% filter(CODIGO_POSTAL == cod_postal)
  df_medias <- tabla_medias %>% filter(CODIGO_POSTAL == cod_postal)

  if (nrow(df_frecuencias) == 0 | nrow(df_medias) == 0) return(NULL)

  df_frecuencias_long <- df_frecuencias %>%
    select(where(is.numeric)) %>%
    pivot_longer(cols = everything(), names_to = "Categoria", values_to = "Cantidad")

  df_medias_long <- df_medias %>%
    select(where(is.numeric)) %>%
    pivot_longer(cols = everything(), names_to = "Categoria", values_to = "Media_CO2")

  df_final <- left_join(df_frecuencias_long, df_medias_long, by = "Categoria") %>%
    filter(Categoria %in% names(colores_categorias)) %>%
    mutate(Porcentaje = (Cantidad / sum(Cantidad, na.rm = TRUE)) * 100)

  ggplot(df_final, aes(x = "", y = Cantidad, fill = Categoria)) +
    geom_bar(stat = "identity", width = 1, color = "black") +
    coord_polar("y") +
    theme_void() +
    scale_fill_manual(values = colores_categorias) +
    labs(title = paste("Distribuci√≥n de Certificados en", cod_postal), fill = "Categor√≠a")
}

# --- Crear gr√°fico de tarta de usos simplificados ---
crear_grafico_usos <- function(tabla_usos, cod_postal) {
  df_usos <- tabla_usos %>%
    filter(CODIGO_POSTAL == cod_postal) %>%
    select(where(is.numeric)) %>%
    pivot_longer(cols = everything(), names_to = "Uso", values_to = "Cantidad")

  if (nrow(df_usos) == 0 || sum(df_usos$Cantidad) == 0) return(NULL)

  df_usos <- df_usos %>%
    mutate(Porcentaje = (Cantidad / sum(Cantidad, na.rm = TRUE)) * 100)

  ggplot(df_usos, aes(x = "", y = Cantidad, fill = Uso)) +
    geom_bar(stat = "identity", width = 1, color = "black") +
    coord_polar("y") +
    theme_void() +
    labs(title = paste("Distribuci√≥n de Usos en", cod_postal), fill = "Uso")
}

# --- Interfaz UI ---
ui <- fluidPage(
  titlePanel("Mapa de emisiones de CO‚ÇÇ y usos del suelo en Valencia"),
  leafletOutput("mapa"),
  h3("Gr√°fico de Letras Energ√©ticas"),
  plotOutput("grafico_tarta"),
  h3("Gr√°fico de Usos Simplificados"),
  plotOutput("grafico_usos"),
  h3("Tabla resumen de letras energ√©ticas"),
  tableOutput("tabla_resultados")
)

# --- L√≥gica SERVER ---
server <- function(input, output, session) {
  # Paleta para colores de pol√≠gonos
  paleta_colores <- colorFactor(
    palette = colores_categorias,
    domain = codigos_postales_mapa_final$EMISIONES_CO2_LETRA
  )

  # Crear variable reactiva para el c√≥digo postal clicado
  selected_postal_code <- reactiveVal(NULL)

  # Mapa principal
  output$mapa <- renderLeaflet({
    leaflet(codigos_postales_mapa_final) %>%
      addTiles() %>%
      addPolygons(
        fillColor = ~paleta_colores(EMISIONES_CO2_LETRA),
        color = "black",
        weight = 1,
        fillOpacity = 0.7,
        highlight = highlightOptions(weight = 3, color = "red", fillOpacity = 0.9),
        layerId = ~CODIGO_POSTAL,
        popup = ~paste0(
          "<b>C√≥digo Postal:</b> ", CODIGO_POSTAL, "<br>",
          "<b>Municipio:</b> ", MUNICIPIO_REFERENCIAS, "<br>",
          "<b>Media CO‚ÇÇ:</b> ", round(Media_Emisiones_CO2, 1), " kg/m¬≤¬∑a√±o<br>",
          "<b>Letra:</b> ", EMISIONES_CO2_LETRA, "<br>",
          "<b>Uso predominante:</b> ", asignar_emoji_uso(Uso_Dominante), " ", Uso_Dominante, "<br>",
          "<b>Total certificados:</b> ", Suma_Total
        )
      )
  })

  # Detectar selecci√≥n de zona
  observeEvent(input$mapa_shape_click, {
    selected_postal_code(input$mapa_shape_click$id)
  })

  # Gr√°fico de letras
  output$grafico_tarta <- renderPlot({
    req(selected_postal_code())
    crear_grafico_tarta(
      tabla_frecuencias_pivotada,
      tabla_medias_pivotada,
      selected_postal_code(),
      colores_categorias
    )
  })

  # Gr√°fico de usos
  output$grafico_usos <- renderPlot({
    req(selected_postal_code())
    # Crear alias para gr√°fico de usos
    tabla_uso_simplificado <- tabla_uso_edificio_pivotada
    crear_grafico_usos(tabla_uso_simplificado, selected_postal_code())
  })

  # Tabla resumen
  output$tabla_resultados <- renderTable({
    req(selected_postal_code())

    df_frec <- tabla_frecuencias_pivotada %>%
      filter(CODIGO_POSTAL == selected_postal_code()) %>%
      select(where(is.numeric)) %>%
      pivot_longer(cols = everything(), names_to = "Categoria", values_to = "Cantidad")

    df_med <- tabla_medias_pivotada %>%
      filter(CODIGO_POSTAL == selected_postal_code()) %>%
      select(where(is.numeric)) %>%
      pivot_longer(cols = everything(), names_to = "Categoria", values_to = "Media_CO2")

    left_join(df_frec, df_med, by = "Categoria") %>%
      mutate(Porcentaje = (Cantidad / sum(Cantidad)) * 100) %>%
      select(Categoria, Cantidad, Media_CO2, Porcentaje)
  })
}

# Lanzar app
shinyApp(ui, server)


```

### üó∫Ô∏è An√°lisis espacial de emisiones medias de CO‚ÇÇ por c√≥digo postal

El siguiente mapa representa la **media de emisiones de CO‚ÇÇ (kg/m¬≤¬∑a√±o)** de los inmuebles con certificado energ√©tico en cada **c√≥digo postal** de la ciudad de Valencia y alrededores.

> ‚ö†Ô∏è **Importante**:\
> El color del pol√≠gono **no representa el n√∫mero de certificados**, sino el **valor medio de emisiones** registrado en la zona.
> Cuanto m√°s oscuro el color, **mayor la media de CO‚ÇÇ** por metro cuadrado.

------------------------------------------------------------------------

### üèöÔ∏è Zonas residenciales con mayores emisiones

-   En el **Cabanyal (46011)** y √°reas portuarias, se superan los **30 kg/m¬≤¬∑a√±o** de media.\
    üëâ Esto es coherente con la presencia de **viviendas antiguas y sin rehabilitaci√≥n energ√©tica**.

-   Otras zonas como el **Carmen** o **partes de Russafa** presentan tambi√©n valores elevados, probablemente debido a **bloques de viviendas envejecidos**.

------------------------------------------------------------------------

### üè≠ Sectores con uso industrial o terciario

-   En √°reas como **Paterna (46980, 46988)** las emisiones son elevadas y **coherentes con su uso dominante**:
    -   **Oficinas**\
    -   **Naves industriales**\
    -   **Grandes superficies**

Estas tipolog√≠as suelen tener **consumos energ√©ticos mayores**, justificando los valores observados.

------------------------------------------------------------------------

### ‚úÖ Conclusiones del an√°lisis espacial

-   Existen **diferencias claras** entre zonas residenciales, comerciales e industriales.\
-   Los **barrios m√°s antiguos presentan peores indicadores** de eficiencia energ√©tica.\
-   El an√°lisis permite **identificar prioridades de intervenci√≥n** y **verificar posibles errores** en la base de datos.

------------------------------------------------------------------------

### Agrupar edificios para identificar los comportamientos en la ciudad de Valencia

Realizar un **clustering jer√°rquico** que agrupe edificios de Valencia en funci√≥n de:

-   **Emisiones de CO‚ÇÇ por m¬≤¬∑a√±o**

-   **Antig√ºedad del edificio**

-   **Superficie construida**

-   **Uso principal del edificio** (transformado a dummies)

Buscamos **detectar patrones de comportamiento energ√©tico** entre edificios con caracter√≠sticas similares, lo que puede ayudar a:

-   Identificar zonas cr√≠ticas.

-   Orientar pol√≠ticas de rehabilitaci√≥n energ√©tica.

-   Relacionar los clusters con otros factores (tr√°fico, contaminaci√≥n, etc.).

## Preparado de datos

# Muestra

Debido a la extensi√≥n de los datos, se ha decidido hacer una muestra estratificada por uso, y consideramos que es la mejor forma de reducir el tama√±o del dataset sin perder representatividad de los diferentes tipos de edificios, para un 99% de confianza y en error +-1% necesitar√≠amos una muestra de 14988 registros

```{r , echo=FALSE}

# --- 1. Par√°metros del muestreo ---
set.seed(123)  # Fijar semilla para reproducibilidad

n_muestra_total <- 14988  # Tama√±o calculado para 99% de confianza y 1% error

# --- 2. Calcular proporciones por tipo de uso ---
proporciones <- data %>%
  count(uso_simplificado, name = "n_total") %>%
  mutate(peso = n_total / sum(n_total),
         n_muestra = round(peso * n_muestra_total))

# --- 3. Agrupar y dividir datos por uso ---
grupos <- data %>%
  filter(uso_simplificado %in% proporciones$uso_simplificado) %>%
  group_split(uso_simplificado)

# --- 4. Muestreo estratificado exacto por uso ---
muestra_estratificada <- map2_dfr(
  grupos,
  proporciones$n_muestra,
  ~ slice_sample(.x, n = min(nrow(.x), .y))
)

```

# Verificar la muestra

Se pens√≥ en hacer una prueba de t de student, pero no tenemos datos que sigan la distribuci√≥n de normalidad, por lo que se ha decidido hacer una prueba de Wilcoxon, que es m√°s robusta a la no normalidad de los datos.

Hip√≥tesis:

H‚ÇÄ (nula): la media de la muestra es igual a la media de la poblaci√≥n.

H‚ÇÅ (alternativa): la media de la muestra no es igual a la media de la poblaci√≥n.

```{r , echo=FALSE}

# --- 5. Verificar la muestra ---
# Variables num√©ricas a comparar
vars <- c("EMISIONES_CO2_VALOR", "SUPERFICIE_M2", "antiguedad")
# Realizar la prueba de Wilcoxon para cada variable
library(dplyr)
library(purrr)
library(tibble)

# Variables a comparar
vars <- c("EMISIONES_CO2_VALOR", "SUPERFICIE_M2", "antiguedad")

# Realizar la prueba de Wilcoxon
resultados_wilcoxon <- map_dfr(vars, function(var) {
  # Verifica que la variable existe en ambos dataframes
  if (!var %in% names(data) || !var %in% names(muestra_estratificada)) {
    return(tibble(variable = var, p_value = NA, reject_null = NA))
  }

  # Elimina NA antes de aplicar el test
  x <- data[[var]]
  y <- muestra_estratificada[[var]]

  x <- x[!is.na(x)]
  y <- y[!is.na(y)]

  # Aseg√∫rate de que ambos son num√©ricos
  if (!is.numeric(x) || !is.numeric(y)) {
    return(tibble(variable = var, p_value = NA, reject_null = NA))
  }

  wilcox_test <- wilcox.test(x, y, paired = FALSE)

  tibble(
    variable = var,
    p_value = wilcox_test$p.value,
    reject_null = wilcox_test$p.value < 0.05
  )
})

print(resultados_wilcoxon)
```

No rechazamos la hip√≥tesis nula, por lo que podemos concluir que la media de muestra es representativa de la poblaci√≥n y podemos seguir con nuestro objetivo.

# Crear variable

Calcular antig√ºedad.
La edad de un edificio afecta directamente a su comportamiento energ√©tico.
Los edificios m√°s antiguos suelen tener peor aislamiento, instalaciones ineficientes y peores materiales constructivos.
Usamos 2025 como referencia fija para comparar todos los casos.

```{r , echo=FALSE}
# --- 5. Calcular antig√ºedad y escalar variables num√©ricas ---
muestra_estratificada <- muestra_estratificada %>%
  mutate(antiguedad = 2025 - ANYO_CONSTRUCCION)


```

# Selecci√≥n de variables

Incluimos √∫nicamente las variables que aportan informaci√≥n √∫til al an√°lisis, y eliminamos aquellas observaciones incompletas que podr√≠an distorsionar los resultados (clustering no tolera bien los NA).

EMISIONES_CO2_VALOR: variable clave a estudiar.

Antig√ºedad: impacto estructural.

SUPERFICIE_M2: tama√±o influye en demanda energ√©tica.

uso_simplificado: es un determinante del comportamiento del edificio.

```{r , echo=FALSE}

vars_clustering <- muestra_estratificada %>%
  filter(!is.na(EMISIONES_CO2_VALOR), !is.na(SUPERFICIE_M2), !is.na(antiguedad), !is.na(uso_simplificado)) %>%
  select(EMISIONES_CO2_VALOR, antiguedad, SUPERFICIE_M2, uso_simplificado)

```

# Codificar la variable categ√≥rica uso_simplificado con variables dummy

Los algoritmos de clustering no trabajan directamente con variables categ√≥ricas.
Por eso convertimos cada uso posible en una variable binaria 0/1 (si es de ese tipo o no).
Esto permite representar diferentes tipos de uso (vivienda, oficina, comercial...) sin orden artificial.

```{r , echo=FALSE}

datos_clustering <- dummy_cols(
  vars_clustering,
  select_columns = "uso_simplificado",
  remove_first_dummy = TRUE,
  remove_selected_columns = TRUE
)

```

# Escalado y centrado de variables

Los algoritmos de clustering son sensibles a la escala de las variables.
Si una variable (como SUPERFICIE_M2) tiene un rango muy alto, dominar√° la distancia total, anulando el efecto de las dem√°s.

```{r , echo=FALSE}
datos_scaled <- scale(datos_clustering, center = TRUE, scale = TRUE)

```

# Elegir Distancia

| Distancia | Tipo de datos | ¬øAdecuada para tu caso? | Comentario breve |
|---------------|----------------|---------------|---------------------------|
| **Eucl√≠dea** | Solo num√©ricas | ‚ùå Parcialmente | No trata bien las dummies como categ√≥ricas |
| **Manhattan** | Num√©ricas | ‚ùå Parcialmente | M√°s robusta, pero mismo problema |
| **Gower** | **Mixtos** (num + categ√≥ricas) | ‚úÖ **S√≠, la mejor opci√≥n** | Trata bien variables num√©ricas y categ√≥ricas |
| Coseno | Num√©ricas, escala similar | ‚ùå | M√°s para texto o vectores direcci√≥n |
| Correlaci√≥n | Num√©ricas | ‚ùå | Para perfiles de comportamiento, no valores brutos |

# C√°lculo de clusters ideal

Se ha probado a hacer directamente pero tras 15 min de ejecuci√≥n se ha decidido hacer un PCA para reducir la cantidad de variables y as√≠ acelerar el proceso, como ya no tendremos un dataset mixto utilizaremos la distancia euclidea.

```{r , echo=FALSE}

# Aplicar PCA con centrado y escalado (ya est√°n escaladas, pero por seguridad)
res_pca <- PCA(datos_scaled, scale.unit = TRUE, ncp = 20, graph = FALSE)

# Visualizar la varianza explicada
fviz_eig(res_pca, addlabels = TRUE, ylim = c(0, 50))  # Scree plot

# Obtener las componentes principales
datos_pca <- as.data.frame(res_pca$ind$coord)  # Coordenadas de individuos

# A√±adir el uso simplificado para interpretar mejor los clusters
datos_pca$uso_simplificado <- muestra_estratificada$uso_simplificado

# (Opcional) Visualizar las dos primeras componentes coloreando por uso
fviz_pca_ind(res_pca,
             geom.ind = "point",
             col.ind = datos_pca$uso_simplificado,
             palette = "jco",
             addEllipses = TRUE,
             legend.title = "Uso")

```

Se decide usar para el clustering las 10 componentes principales, ya que explican el 72,4% de la varianza de los datos, no tienen correlaci√≥n entre ellas .
En este caso las variables ahora son cuantitavias as√≠ que son todas cuantitativas y se puede usar la distancia euclidea.
La distancia euclidea nos calcula la distancia entre dos puntos de forma geom√©trica.
Se ha usado el m√©todo de Ward por que se desea minimizar la varianza dentro de cada cluster, lo que es √∫til para crear grupos homog√©neos.
El m√©todo Ward.D2 (que es la versi√≥n moderna) agrupa los puntos minimizando el aumento de varianza total al fusionar dos clusters: por lo que agrupa puntos cercanos y tiene en cuenta la forma y dispersi√≥n de los grupos.

# Creaci√≥n Clusters

Se crea otros clusters para poder

```{r , echo=FALSE}
# --- Librer√≠as necesarias ---

datos_pca <- as.data.frame(res_pca$ind$coord)
datos_pca_reducido <- datos_pca[, 1:10]  # Solo PC1‚ÄìPC10

```

```{r , echo=FALSE}
# --- Paso 3: Determinar el n√∫mero √≥ptimo de clusters ---
set.seed(123)
# --- Paso 2: Calcular la matriz de distancias eucl√≠deas ---
distancias_pca <- dist(datos_pca_reducido, method = "euclidean")

```

```{r , echo=FALSE}

# --- Paso 3: Aplicar clustering jer√°rquico con fastcluster y m√©todo ward.D2 ---
hc_fast <- hclust(distancias_pca, method = "ward.D2")

# --- Paso 4: Determinar el n√∫mero √≥ptimo de clusters visualmente o usando silhouette ---
# Puedes usar el dendrograma o silhouette:
#fviz_nbclust(datos_pca_reducido, FUNcluster = hcut, method = "silhouette", k.max = 15)
```

```{r , echo=FALSE}

# --- Paso 5: Cortar el dendrograma en k clusters ---
clusters <- cutree(hc_fast, k = 11)

# --- Paso 6: Visualizar los clusters ---
fviz_cluster(list(data = datos_pca_reducido, cluster = clusters),
             geom = "point", ellipse.type = "convex",
             palette = "jco", ggtheme = theme_minimal())
```

Obsevamos las estad√≠sticas de los 11 clusters

```{r , echo=FALSE}
# A√±adir los clusters al dataset original
datos_clusterizados <- muestra_estratificada %>%
  mutate(cluster = factor(clusters))

library(dplyr)

# Estad√≠sticas por cluster (media, mediana, desviaci√≥n est√°ndar)
resumen_clusters <- datos_clusterizados %>%
  group_by(cluster) %>%
  summarise(
    n               = n(),
    media_CO2       = mean(EMISIONES_CO2_VALOR, na.rm = TRUE),
    mediana_CO2     = median(EMISIONES_CO2_VALOR, na.rm = TRUE),
    sd_CO2          = sd(EMISIONES_CO2_VALOR, na.rm = TRUE),
    media_sup       = mean(SUPERFICIE_M2, na.rm = TRUE),
    mediana_sup     = median(SUPERFICIE_M2, na.rm = TRUE),
    media_antig     = mean(antiguedad, na.rm = TRUE),
    mediana_antig   = median(antiguedad, na.rm = TRUE)
  ) %>%
  arrange(cluster)

print(resumen_clusters)

# Tabla de usos por cluster
tabla_usos <- datos_clusterizados %>%
  group_by(cluster, uso_simplificado) %>%
  summarise(n = n(), .groups = "drop") %>%
  pivot_wider(names_from = uso_simplificado, values_from = n, values_fill = 0)

print(tabla_usos)
```

Queremos observar el n√∫mero de edificios por cluster.

```{r , echo=FALSE}
library(ggplot2)

ggplot(datos_clusterizados, aes(x = cluster, y = EMISIONES_CO2_VALOR, fill = cluster)) +
  geom_boxplot() +
  labs(title = "Distribuci√≥n de emisiones por cluster", y = "kg CO2/m¬≤¬∑a√±o") +
  theme_minimal()

ggplot(datos_clusterizados, aes(x = cluster, y = SUPERFICIE_M2, fill = cluster)) +
  geom_boxplot() +
  labs(title = "Superficie construida por cluster", y = "m¬≤") +
  theme_minimal()

ggplot(datos_clusterizados, aes(x = cluster, y = antiguedad, fill = cluster)) +
  geom_boxplot() +
  labs(title = "Antig√ºedad por cluster", y = "a√±os") +
  theme_minimal()
```

GRUPO 1: representa el comportamiento medio de los edificios en Valencia.
Predominan las viviendas con valores intermedios de antig√ºedad y emisiones.
Su comportamiento energ√©tico se puede considerar como "est√°ndar" y puede servir como referencia para comparaci√≥n con otros grupos.

GRUPO 2: Edificios con mejor comportamiento energ√©tico.
Se basa en centro educativos

GRUPO 3 Agrupa edificios comerciales con necesidades energ√©ticas elevadas.
La superficie es superior a la del grupo 1 y las emisiones significativamente m√°s altas, lo que apunta a un menor rendimiento energ√©tico o mayores necesidades de climatizaci√≥n.

grupo 4: Son edificios grandes y diversos, mayoritariamente p√∫blicos, cuya eficiencia var√≠a.
Su superficie y antig√ºedad sugieren instalaciones hist√≥ricas o infraestructuras comunitarias.

GRUPO 5,6 Y 8: Estos grupos agrupan edificios con altas emisiones de CO‚ÇÇ, probablemente debido a su uso (gimnasios, hoteles, edificios mal acondicionados), alta superficie y/o antig√ºedad, el 6 y 8 tienen emisiones bastante altas.

GRUPO 7: Este grupo contiene viviendas m√°s viejas que el grupo 1 pero contaminan menos, aunque no hay mucha diferencia

GRUPO 9 : son las industrias y en general emisioens algo m√°s alta pero no son muy excesivo

GRUPO 10: Este grupo contiene edificios de oficinas Y sorprendentemente tienen la misma huella de carbono que las industrias.

GRUPO 11: Los restaurantes son de los que m√°s CO2 emiten , l√≥gicamente por el gran horario de servicio que disponen, las cocinas y el tema de climatiazci√≥n.

## Otro modelo de clustering

Se va a realizar el clustering tan solo con las emisiones de co2, superfice y antig√ºedad debido a que el clustering al incluir uso salen directamente los grupos asociados al uso.
Despu√©s se intentar√° ver si podemos asociarlo a cierto grupo o hay dispersi√≥n.
Se utilizar√° la distancia eucl√≠dea por ser variables num√©ricas y consideramos que los an√≥malos no tendran un gran peso.

```{r , echo=FALSE}
# --- Escalar los datos ---
datos_numeric <- muestra_estratificada %>%
  select(EMISIONES_CO2_VALOR, SUPERFICIE_M2, antiguedad)

datos_scaled <- scale(datos_numeric)

# --- Cargar librer√≠as necesarias ---
library(fastcluster)
library(factoextra)

# --- Calcular matriz de distancias ---
dist_euclidea <- dist(datos_scaled, method = "euclidean")
```

# Seleccionar clusters

```{r , echo=FALSE}
# --- M√©todo del Codo usando hclust optimizado ---

#fviz_nbclust(
 # datos_scaled,
  #FUNcluster = hcut,
  #method = "wss",
  #k.max = 10,
  #hc_method = "ward.D2"
#3) +
 # labs(title = "M√©todo del Codo - FastCluster")
```

```{r , echo=FALSE}

# M√©todo de la Silhouette
#fviz_nbclust(datos_scaled, FUNcluster = hcut, method = "silhouette", k.max = 10) +
 # labs(title = "M√©todo de la Silueta - Clustering Jer√°rquico")
```

# Visualizaci√≥n

Ambas pruebas nos indican que el n√∫mero √≥ptimo de clusters es 8, por lo que se decide usar este n√∫mero.

```{r , echo=FALSE}
library(fastcluster)

# Clustering jer√°rquico
hc <- hclust(dist_euclidea, method = "ward.D2")

# Cortar en k grupos (ajusta seg√∫n resultado anterior)
k_optimo <- 8
grupos <- cutree(hc, k = k_optimo)



# A√±adir clusters al dataset original
datos_clusterizados <- cbind(muestra_estratificada, cluster = as.factor(grupos))

# Visualizar con las dos primeras variables
fviz_cluster(list(data = datos_scaled, cluster = grupos),
             geom = "point", ellipse.type = "convex",
             palette = "jco", ggtheme = theme_minimal())

```

# Interpretaci√≥n

```{r , echo=FALSE}
# Solo si tienes la variable uso_simplificado en tu muestra
tabla_usos <- datos_clusterizados %>%
  group_by(cluster, uso_simplificado) %>%
  summarise(n = n(), .groups = "drop") %>%
  tidyr::pivot_wider(names_from = uso_simplificado, values_from = n, values_fill = 0)

print(tabla_usos)
```

```{r , echo=FALSE}
library(dplyr)

# Estad√≠sticas por cluster (media, mediana, desviaci√≥n est√°ndar)
resumen_clusters <- datos_clusterizados %>%
  group_by(cluster) %>%
  summarise(
    n               = n(),
    media_CO2       = mean(EMISIONES_CO2_VALOR, na.rm = TRUE),
    mediana_CO2     = median(EMISIONES_CO2_VALOR, na.rm = TRUE),
    sd_CO2          = sd(EMISIONES_CO2_VALOR, na.rm = TRUE),
    media_sup       = mean(SUPERFICIE_M2, na.rm = TRUE),
    mediana_sup     = median(SUPERFICIE_M2, na.rm = TRUE),
    media_antig     = mean(antiguedad, na.rm = TRUE),
    mediana_antig   = median(antiguedad, na.rm = TRUE)
  ) %>%
  arrange(cluster)

print(resumen_clusters)

```

Se observa que el comportamiento del cluster 1 sigue el patr√≥n normal de las emisiones de CO2 de zonas de la ciudad donde no hay un exceso de emisiones, lo que ser√≠a el comportamiento habitual del conjunto de la ciudad est√° formado por la mayor√≠a de edificios de viviendas, oficinas, y sobre todo viviendas.

El grupo 2 tiene un comportamiento similar al grupo 1 pero con una media de emisiones de CO2 m√°s baja, lo que podr√≠a indicar que son edificios m√°s nuevos o con mejores caracter√≠sticas energ√©ticas, destacan los colegios, que ser√°n de creaci√≥n reciente; y es el segundo con m√°s viviendas lo que podr√≠a significar que son de nueva contrucci√≥n y por eso en el grupo de m√°s bajas emisiones, si vemos la antig√ºedad es la m√°s baja de todos los grupos, confirma que son los m√°s novedosos y con grandes mejoras de eficiencia energ√©tica que el resto.

El grupo 3 tiene un comportamiento similar al grupo 1 pero con una media de emisiones de CO2 m√°s alta, lo que podr√≠a indicar que son edificios m√°s antiguos o con peores caracter√≠sticas energ√©ticas, destaca la presencia de industrias, la cantidad de colegios se podr√≠a deber debido a su alta necesidad energ√©tica por ser espacio muy grandes y antig√ºamente no se invirt√≠a tanto en eso, algo parecido ocurre con los gimnasios o centros deportivos son lugares en los que las personas est√°n haciendo un esfuerzo f√≠sico y se tiene que climatizar las zonas y con mayor intensidad en especial en verano, es por eso que es l√≥gico que este grupo tenga una media de superficie bastante alta y tambi√©n destacan los hoteles que tienen un gasto energ√©tico superior a la media de edificios.

El grupo 4 destacan las viviendas viejas por ello mayor las emisiones de CO2.

El grupo 5 dir√≠a que son edificios y viviendas muy antiguos y a pesar de no tener buen aislamiento no cuentan con instalaciones de climatizaci√≥n y no emiten dicho gas y hay que a√±adir que hay un edificio del puerto, esto nos ayuda a entender que no emiten tanto CO2, cuando se limpiaron los datos se observ√≥ que la mayor√≠a de lugares del puerto que estaban certificados eran naves de almacenamiento y no ten√≠an apenas emisiones.

El grupo 6 tiene las peores emisiones de CO2, es un conjunto de todo, dir√≠a que son los peores en cuanto emisiones de co2 de cada uso de edificio.

El grupo 7 son hoteles, viviendas recientes pero dir√≠a que de peor calidad constructiva que las del grupo 2, y tambi√©n hay oficinas y hoteles de las mismas caracter√≠sticas.

Finalmente el grupo 8 solo cuenta con un individuo y difiere del resto por su gran superficie, se trata de algo comercial, por la superficie diria un centro comercial.

```{r , echo=FALSE}
library(ggplot2)

ggplot(datos_clusterizados, aes(x = cluster, y = EMISIONES_CO2_VALOR, fill = cluster)) +
  geom_boxplot() +
  labs(title = "Distribuci√≥n de emisiones por cluster", y = "kg CO2/m¬≤¬∑a√±o") +
  theme_minimal()

ggplot(datos_clusterizados, aes(x = cluster, y = SUPERFICIE_M2, fill = cluster)) +
  geom_boxplot() +
  labs(title = "Superficie construida por cluster", y = "m¬≤") +
  theme_minimal()

ggplot(datos_clusterizados, aes(x = cluster, y = antiguedad, fill = cluster)) +
  geom_boxplot() +
  labs(title = "Antig√ºedad por cluster", y = "a√±os") +
  theme_minimal()

```

Al observar las distribuciones de los cluster por variables vemos que en cuanto emisiones es cierto que los 5 primeros grupos tienen un comportamiento similar , que es lo que encontramos de media en la ciduad seg√∫n el plot de emisiones de codigo postal, y se ve el resto que son superiores.
En cuanto a superficie es lo que hemos dicho el 3 son edificios muy grnades y sobre todo en antiguedad si que se puede apreciar diferentes grupos.

‚úÖ Conclusiones generales sobre el comportamiento energ√©tico de los edificios de Valencia Predominio del comportamiento est√°ndar y eficiente en la mayor√≠a de los edificios

El grupo 1, mayoritario, representa el patr√≥n habitual de emisiones de CO‚ÇÇ en Valencia.
Se compone sobre todo de viviendas y oficinas con emisiones moderadas, lo que refleja el comportamiento energ√©tico t√≠pico de la ciudad.

El grupo 2 destaca por tener las emisiones m√°s bajas, asociadas a edificios m√°s recientes, especialmente colegios y viviendas de nueva construcci√≥n, con mejor eficiencia energ√©tica y menor antig√ºedad.

Presencia de grupos con mayor impacto energ√©tico

El grupo 3 presenta emisiones m√°s elevadas, con una composici√≥n marcada por industrias, centros deportivos, colegios antiguos y hoteles.
Este grupo concentra usos con mayor demanda energ√©tica y construcciones m√°s antiguas y menos eficientes.

El grupo 4 y grupo 6 incluyen viviendas envejecidas y un conjunto heterog√©neo de edificios con las peores cifras de CO‚ÇÇ, respectivamente.
Esto apunta a la existencia de zonas vulnerables energ√©ticamente que podr√≠an ser prioritarias en pol√≠ticas de rehabilitaci√≥n.

Casos especiales con patrones propios

El grupo 5 edificios muy antiguos pero con bajas emisiones, posiblemente por ausencia de climatizaci√≥n o funciones de almacenamiento sin consumo energ√©tico relevante (ej. naves en el puerto) y otros que  han sido reformados.

El grupo 7 se compone de viviendas y hoteles relativamente recientes pero con peor comportamiento energ√©tico, posiblemente por materiales de baja calidad o mala eficiencia constructiva.

El grupo 8 representa un outlier, probablemente un centro comercial de gran superficie, cuyas caracter√≠sticas lo diferencian completamente del resto.

### Analizar la inflencia

Se agrupan los datos por parcelas catastrales y reorganizamos las categor√≠as de uso para que sean m√°s comprensibles, se suma superficies y se calcula la media de emisiones de co2.
Se busca estudiar la posible inlfuencia del CO2 a los contaminantes.

```{r , echo=FALSE}
# Agrupar por parcelas catastrales
data_parcelas <- data %>%
  group_by(parcela_catastral) %>%
  summarise(
    EMISIONES_CO2_VALOR = mean(EMISIONES_CO2_VALOR, na.rm = TRUE),
    SUPERFICIE_M2        = sum(SUPERFICIE_M2, na.rm = TRUE),
    antiguedad           = 2025 - mean(ANYO_CONSTRUCCION, na.rm = TRUE),
    lat                  = mean(lat, na.rm = TRUE),
    lon                  = mean(lon, na.rm = TRUE),
    CODIGO_POSTAL        = first(CODIGO_POSTAL),
    uso_agregada = case_when(
      any(uso_simplificado %in% c("Industrial"))                        ~ "Industrial",
      any(uso_simplificado %in% c("Comercial", "Oficina"))             ~ "Comercial",
      any(uso_simplificado %in% c("Vivienda", "Edificio de Viviendas"))~ "Residencial",
      any(uso_simplificado %in% c("Sanitario", ""))                    ~ "Sanitario",
      any(uso_simplificado %in% c("Centro de Ense√±anza"))              ~ "Centro de Ense√±anza",
      any(uso_simplificado %in% c("Hotel"))                            ~ "Hotel",
      any(uso_simplificado %in% c("Cultural", "Religioso"))            ~ "Cultural/Religioso",
      any(uso_simplificado %in% c("Deportivo"))                        ~ "Deportivo",
      any(uso_simplificado %in% c("Restaurante"))                      ~ "Restaurante",
      TRUE                                                             ~ "Otros"
    )
  ) %>%
  ungroup()


```

```{r , echo=FALSE}
head(data_parcelas,10)

```

Se va a realizar un clustering para poder estudiar el comportamiento de los edificios de VALENCIA, del estilo al anterior pero esto es en conjunto

## Modelo con parcelas

Se va a realizar el clustering con las parcelas tan solo con las emisiones de co2, superfice y antig√ºedad debido a que el clustering al incluir uso salen directamente los grupos asociados al uso.

```{r , echo=FALSE}
# --- Escalar los datos ---
datos_numeric <- data_parcelas%>%
  select(EMISIONES_CO2_VALOR, SUPERFICIE_M2, antiguedad)

datos_scaled <- scale(datos_numeric)

# --- Cargar librer√≠as necesarias ---
library(fastcluster)
library(factoextra)

# --- Calcular matriz de distancias ---
dist_euclidea <- dist(datos_scaled, method = "euclidean")
```

# Seleccionar clusters

```{r , echo=FALSE}

# 2. Cargar librer√≠as
library(factoextra)

# 3. Determinar n√∫mero √≥ptimo de clusters (M√©todo del Codo)
#set.seed(123)
#fviz_nbclust(datos_scaled, kmeans, method = "wss", k.max = 10) +
  #labs(title = "M√©todo del Codo - K-means")
```

```{r , echo=FALSE}
# --- M√©todo de la Silhouette ---
#set.seed(123)
#fviz_nbclust(datos_scaled, kmeans, method = "silhouette", k.max = 10) +
 # labs(title = "M√©todo de la Silhouette - K-means")
```

Han salido 7 clusters como lo √≥ptimo

```{r , echo=FALSE}
# Elegimos k
set.seed(123)
k_opt <- 7
kmeans_result <- kmeans(datos_scaled, centers = k_opt, nstart = 25)

# A√±adir cluster al dataframe original
data_parcelas$cluster_kmeans <- factor(kmeans_result$cluster)
```

# Visualizaci√≥n de los clusters

```{r , echo=FALSE}
fviz_cluster(kmeans_result, data = datos_scaled,
             geom = "point",
             ellipse.type = "convex",
             ggtheme = theme_minimal())

```
# An√°lisis de los clusters obtenidos

```{r , echo=FALSE}

# 2. Estad√≠sticas descriptivas por cluster
library(dplyr)

estadisticas_clusters <- data_parcelas %>%
  group_by(cluster_kmeans) %>%
  summarise(
    n = n(),
    
    media_CO2        = mean(EMISIONES_CO2_VALOR, na.rm = TRUE),
    mediana_CO2      = median(EMISIONES_CO2_VALOR, na.rm = TRUE),
    
    media_superficie = mean(SUPERFICIE_M2, na.rm = TRUE),
    mediana_superficie = median(SUPERFICIE_M2, na.rm = TRUE),
    
    media_antiguedad = mean(antiguedad, na.rm = TRUE),
    mediana_antiguedad = median(antiguedad, na.rm = TRUE)
  )

print(estadisticas_clusters)

# Distribuci√≥n por uso agregado en cada cluster
distribucion_uso <- data_parcelas %>%
  group_by(cluster_kmeans, uso_agregada) %>%
  summarise(n = n(), .groups = "drop") %>%
  tidyr::pivot_wider(names_from = uso_agregada, values_from = n, values_fill = 0)

print(distribucion_uso)


head(data_parcelas,10)


```

GRUPO 1: Agrupa edificios de caracter comecial con una superficie media 73000 m2, tienen una antig√ºedad media de 31 a√±os , aunque la mediana es de 23 a√±os, por lo que son edificios relativamente nuevos , tienen unas emisiones bajas si lo comparamos con el resto de clusters, hablamos de 28kg de CO2 por m2 al a√±o, lo que es un comportamiento energ√©tico medio .
Edificios con superficie grande pero emsiones est√°n en torno a la media por m2.

GRUPO 2: Destacan los edificios de caracter residencial con una antig√ºedad de 57 a√±os y un alto porcentaje de hoteles.
Descatan tambi√©n los restaurantes, todos estos tienen unas emisiones altas 62.94658 kg de CO2 por m2 al a√±o, lo que es un comportamiento energ√©tico poco eficiente y seguramente sea debido a su antig√ºedad y a que no se han realizado reformas de mejora energ√©tica.
En conclusi√≥n, Edificios algo antiguos con altas emisiones de CO2

GRUPO 3: Tienen emisiones bajas, tienen una antig√ºedad media de 25 a√±os, se tratan de un buen porcentaje de los colegios centro deportivos, tambi√©n destaca los colegios,viviendas y restaurantes. Por lo tanto, son edificios nuevos con emisiones bajas, hablamos de 22 kg por m2 al a√±o.

GRUPO 4: Agrupa a la mayor cantidad de parcelas catastrales, hablamos de edificios de 58 a√±os con emisiones en torno a la media sobre 30 .
Pertenecen a este grupo gran parte de los comercios, industriales y los restautantes y los colegios y sibre todo residenciales.
Edificios normales (lo habitual), emisiones medio-altas.

GRUPO 5: Un grupo bastante gen√©rico con un comportamiento similar al grupo 4, pero con una antig√ºedad media de 100 a√±os .
Edificios viejos con emisiones medias.

GRUPo 6: Edificios que han realizado mejoras energ√©ticas seguramente, esto se explica a su antig√úedad (43 a√±os de media) y a sus bajas emisiones.
Destacan comercios, y viviendas.
Edificios reformados.

GRUPO 7: Casos extremos con emisiones muy por encima, tienen una media de 400 kg/m2 al a√±o , se tratan de comercios y residenciales, tienen una antiguedad de 88 a√±os. 

En resumen:

üîπ Cluster 1: üü® "Grandes edificios recientes con eficiencia media"

üîπ Cluster 2: üü• "Edificios antiguos con alta ineficiencia"

üîπ Cluster 3: üü© "Edificios nuevos y diversos con alta eficiencia energ√©tica"

üîπ Cluster 4: üü¶ "Edificios con poca antiguedad con eficiencia media"

üîπ Cluster 5: ‚¨õ "Edificios muy antiguos con eficiencia moderada"

üîπ Cluster 6: üüß "Edificios reformados con buena eficiencia energ√©tica"

üîπ Cluster 7: üü• "Casos extremos de ineficiencia energ√©tica"

Como hemos podido identificar el comportamiento de los edificios vamos a proceder a realizar un clustering geogr√°fico para ver si hay zonas homog√©neas en cuanto a emisiones de CO2 y as√≠ poder relacionarlo con las zonas que estudian cada estaci√≥n de contaminaci√≥n.

### Mapa geogr√°fico y la distribuci√≥n de las coordenadas

Se agruparan los edificios en torno a las coordenadas de las estaciones de contaminaci√≥n, para ver si hay zonas homog√©neas en cuanto a emisiones de CO2 y as√≠ poder relacionarlo con los contaminantes.
Se realizar√° un clustering basado en gemotr√≠a de Varonoi

```{r , echo=FALSE}


# Filas con lat o lon faltantes
filas_malas <- data_parcelas %>%
  filter(is.na(lat) | is.na(lon))

# Mostrar las primeras filas problem√°ticas
head(filas_malas)

# Contar cu√°ntas hay
nrow(filas_malas)
data_parcelas <- data_parcelas %>%
  filter(!is.na(lat) & !is.na(lon))

sum(data_parcelas$cluster_kmeans == 7)
head(data_parcelas,10)

#Volvemos a eliminar las filas mal geolocalizadas por si no han sido eliminadas 

referencias_a_eliminar <- c(
  "46246A03300153", "5481413YJ2658A", "6462907YJ2766A", "46246A02700129", "46246A02500187",
  "46246A03001172", "4155617YJ2745E", "46246A03000417", "7173219YJ1677S", "46246A02600336",
  "5574209YJ2657S", "46246A03001226", "7728122YJ2772H", "5912335YJ2751B", "6212322YJ2761C",
  "46246A02600652", "46246A03001304", "6520819YJ2762B", "46246A03100108", "4723124YJ1742S",
  "5583104YJ1758S", "2428811YJ2722N", "46246A02600539", "6519422YJ2761H", "46246A02700106",
  "4045808YJ2644N", "9826603YJ2792F", "46246A03001029", "46246A00900243", "8485807YJ1688N",
  "5738220YJ2753H", "46246A02900017", "2431707YJ2723S", "4523104YJ1742S", "46246A03000069",
  "7932211YJ2773D", "7913208YJ1871S", "46246A03000108", "7365530YJ1676N", "5773116YJ1657S",
  "002040900YJ06F", "46246A04700031", "5913108YJ2751D", "5482503YJ1658S", "5944120YJ2754D",
  "46246A03200101", "46246A03200160", "5247418YJ2754G", "7624409YJ2772D", "9307111YJ2790E",
  "7612310YJ1871S", "46246A02600558", "46246A03001362", "46246A03001105", "5292113YJ1759S",
  "6943313YJ2764D", "6682110YJ1768S", "4338605YJ2743G", "6017411YJ2761E", "46246A02600472",
  "5571365YJ2657S", "46246A03200170", "46246A04800018", "9622315YJ2792D", "4655810YJ2745F",
  "7975108YJ1677N", "5384708YJ1758S", "5586718YJ1758N", "46246A04800152", "5172805YJ2657S",
  "46246A04900042", "46246A03000901", "2068514YJ2726N", "46246A03000794", "9940302YJ2794B",
  "9626418YJ2792F", "46246A04600140", "46246A03200074", "7612308YJ1871S", "46246A03001411",
  "8223722YJ2782C", "46246A03001317", "5583108YJ1758S", "8390608YJ1689S", "5582907YJ1758S",
  "46246A00100105", "5841220YJ2754B", "9937621YJ2793F", "2877916YJ2627N", "7520614YJ2772B",
  "46246A02600453", "46246A03001107", "46246A03200158", "46246A02900100", "2263112YJ2726S",
  "46246A00200424", "46246A05200099", "46246A02900107", "46246A02600470", "9415316YJ2791E",
  "3645213YJ2634N", "4220318YJ2742A"
)
data_parcelas <- data_parcelas %>%
  filter(!parcela_catastral %in% referencias_a_eliminar)

```




```{r , echo=FALSE}
# app.R
# app.R

# Sensores (con columnas: Estaci√≥n, Latitud, Longitud)
sensores <- read.csv("estaciones_valencia.csv") %>%
  rename(lat = Latitud, lon = Longitud, nombre = Estaci√≥n)


library(shiny)
library(leaflet)
library(sf)
library(dplyr)
library(RColorBrewer)
library(ggplot2)

# ============================
# CARGA Y PREPARACI√ìN DE DATOS
# ============================

# Leer datos
sensores <- read.csv("estaciones_valencia.csv") %>%
  rename(lat = Latitud, lon = Longitud, nombre = Estaci√≥n)

sensores_sf <- st_as_sf(sensores, coords = c("lon", "lat"), crs = 4326)
sensores_utm <- st_transform(sensores_sf, 3857)

# Crear Voronoi
voronoi_pol <- st_voronoi(st_union(sensores_utm))
voronoi_pol <- st_collection_extract(voronoi_pol)
voronoi_sf <- st_sf(geometry = voronoi_pol) %>%
  st_join(sensores_utm) %>%
  st_transform(4326)



etiquetas <- c(
  "1" = "Grandes edificios  recientes con eficiencia media",
  "2" = "Edificios antiguos con alta ineficiencia",
  "3" = "Edificios nuevos y diversos con alta eficiencia energ√©tica",
  "4" = "Edificios con poca antiguedad con eficiencia media",
  "5" = "Edificios muy antiguos con eficiencia moderada",
  "6" = "Edificios reformados con buena eficiencia energ√©tica",
  "7" = "Casos extremos de ineficiencia energ√©tica"
)

data_parcelas$clase_energetica <- etiquetas[as.character(data_parcelas$cluster_kmeans)]
edificios_sf <- st_as_sf(data_parcelas, coords = c("lon", "lat"), crs = 4326)
edificios_sensor <- st_join(edificios_sf, voronoi_sf["nombre"])
# A√±adir el nombre del sensor m√°s cercano a data_parcelas
data_parcelas$sensor_cercano <- edificios_sensor$nombre
# Calcular emisiones por zona (toneladas)
emisiones_por_sensor <- edificios_sensor %>%
  mutate(emisiones_total = SUPERFICIE_M2 * EMISIONES_CO2_VALOR / 1000) %>%
  group_by(nombre) %>%
  summarise(emisiones_totales = round(sum(emisiones_total, na.rm = TRUE), 1))

# Unir al voronoi
voronoi_sf <- left_join(voronoi_sf, st_drop_geometry(emisiones_por_sensor), by = "nombre")


# Paletas
pal_sensores <- colorFactor(brewer.pal(8, "Set2"), domain = sensores$nombre)
pal_cluster <- colorFactor(brewer.pal(7, "Set1"), domain = unique(data_parcelas$clase_energetica))

# ============================
# UI
# ============================

ui <- fluidPage(
  titlePanel("Mapa energ√©tico de edificios y sensores de Val√®ncia"),
  sidebarLayout(
    sidebarPanel(
      textOutput("titulo_sensor"),
      plotOutput("grafico_sensor"),
      htmlOutput("leyenda_sensor")
    ),
    mainPanel(
      leafletOutput("mapa", height = "800px")
    )
  )
)

# ============================
# SERVER
# ============================

server <- function(input, output, session) {
  # Valor reactivo para almacenar el sensor clicado
  sensor_seleccionado <- reactiveVal(NULL)

  observeEvent(input$mapa_shape_click, {
    sensor <- input$mapa_shape_click$id
    sensor_seleccionado(sensor)
  })

  output$titulo_sensor <- renderText({
    req(sensor_seleccionado())
    paste("Sensor seleccionado:", sensor_seleccionado())
  })

  output$grafico_sensor <- renderPlot({
    req(sensor_seleccionado())

    datos <- edificios_sensor %>% filter(nombre == sensor_seleccionado())
    if (nrow(datos) == 0) return(NULL)

    tabla <- datos %>% count(clase_energetica, name = "n") %>%
      mutate(prop = round(100 * n / sum(n), 1))

    barplot(
      tabla$n,
      names.arg = tabla$clase_energetica,
      las = 2,
      col = brewer.pal(7, "Set1")[seq_len(nrow(tabla))],
      main = "Distribuci√≥n por eficiencia energ√©tica",
      horiz = TRUE,
      cex.names = 0.7,
      cex.axis = 0.8,
      cex.main = 1.1
    )
  })

  output$leyenda_sensor <- renderUI({
    req(sensor_seleccionado())
    datos <- edificios_sensor %>% filter(nombre == sensor_seleccionado())
    if (nrow(datos) == 0) return(NULL)

    tabla <- datos %>% count(clase_energetica, name = "n") %>%
      mutate(prop = round(100 * n / sum(n), 1))

    colores <- brewer.pal(7, "Set1")[seq_len(nrow(tabla))]

    HTML(paste0(
      "<ul style='padding-left: 0px; list-style: none;'>",
      paste0("<li><span style='display:inline-block;width:12px;height:12px;background-color:", colores, ";margin-right:5px;'></span>",
             tabla$clase_energetica, ": <b>", tabla$prop, "%</b></li>"),
      "</ul>"
    ))
  })

  output$mapa <- renderLeaflet({
    leaflet() %>%
      addTiles() %>%
      addPolygons(
        data = voronoi_sf,
        layerId = ~nombre,
        fillColor = ~pal_sensores(nombre),
        color = "black",
        weight = 1,
        fillOpacity = 0.2,
        label = ~paste0(nombre, "\nEmisiones: ", emisiones_totales, " t CO‚ÇÇ/a√±o")
      ) %>%
      addCircleMarkers(
        data = edificios_sensor,
        radius = 3,
        color = ~pal_cluster(clase_energetica),
        stroke = FALSE,
        fillOpacity = 0.9
      )
  })
}

# ============================
# LANZAR APP
# ============================

shinyApp(ui = ui, server = server)


```

## CONCLUSIONES POR REGIONES 

Se ha realizado un clustering geogr√°fico de los edificios de Valencia, agrupando las coordenadas de los edificios en torno a las estaciones de contaminaci√≥n.

1. Valencia- Pista de Silla 
Emisiones totales: 1.430.974 toneladas CO‚ÇÇ/a√±o

Caracter√≠sticas: Esta regi√≥n se presenta como el punto m√°s cr√≠tico en cuanto a impacto clim√°tico. La gran mayor√≠a de sus edificaciones son antiguas, con altos niveles de ineficiencia energ√©tica. A pesar de la presencia de algunos edificios reformados, el volumen global de construcciones con bajo rendimiento energ√©tico hace que las emisiones totales sean extremadamente elevadas.Tenemos que redordar que es la parte de m√°s certificados se han presentado , por la gran presencia del mercado mobiliario o para mejorarlos eficentemente.


2. Val√®ncia - Mol√≠ del Sol
Emisiones totales: 1.061.190 toneladas CO‚ÇÇ/a√±o

Mol√≠ del Sol tambi√©n destaca por un volumen de emisiones muy alto. La mayor√≠a de los edificios son antiguos y carecen de actuaciones significativas de mejora energ√©tica. La baja proporci√≥n de edificaciones nuevas o reformadas evidencia una situaci√≥n de estancamiento urbano.

3. Torrent - El Vedat
Emisiones totales: 625.183 toneladas CO‚ÇÇ/a√±o

Caracter√≠sticas: Se trata de una zona con un perfil mixto, en el que conviven edificios muy antiguos, construcciones comerciales y una cierta presencia de eficiencia media. Las emisiones son elevadas, aunque no extremas.


4.Valenica- Politecnic
Emisiones totales: 615.600 toneladas de CO‚ÇÇ/a√±o
Esta zona, vinculada en parte al √°mbito universitario y de servicios p√∫blicos, presenta una infraestructura antigua con bajo nivel de renovaci√≥n. La eficiencia energ√©tica media es deficiente, y escasea la presencia de edificios nuevos .


5. Quart de Poblet
Emisiones totales: 542.559 toneladas de CO‚ÇÇ/a√±o
Se observa una fuerte concentraci√≥n de edificios antiguos, con pocos signos de mejora energ√©tica reciente. Aunque el volumen total de emisiones no es tan alto como en otras zonas, el perfil urbano muestra una eficiencia estancada.


6. Val√®ncia - Av. Fran√ßa
Emisiones totales: 361.143 toneladas de CO‚ÇÇ/a√±o
Zona con un parque inmobiliario envejecido  pero con una eficiencia que est√° en la media, tambi√©n tiene un buen % de edificios nuevos o con grandes mejroas energ√©ticas. 


7. Massanassa
Emisiones totales: 282.906 toneladas de CO‚ÇÇ/a√±o
Zona de car√°cter marcadamente comercial e industrial, donde predominan edificaciones de eficiencia energ√©tica media o baja, debido a que un % han sido reformados. 



8. Val√®ncia Port Moll Transports Ponent
Emisiones totales: 95.816,7 toneladas de CO‚ÇÇ/a√±o

Predominan edificios antig√ºos uanque toma mucho peso tambi√©n la parte de los reformados siendo muy eficientes. Los nivles de emisiones son moderados pero si se tuviera en cuenta otras acciones la zona de puerto deber√≠a de ser de los que m√°s co2 emiten. 

9. Val√®ncia Port llit antic T√∫ria
Emisiones totales: 80.123 toneladas de CO‚ÇÇ/a√±o
Zona hist√≥rica con baja densidad de emisiones. Pero es debido a la poca concentraci√≥n de edificaciones residenciales, estas zonas realemente tienen muchas emisiones de CO2 por las combustiones genradas en el puerto pero en los CEE no se tienen en cuenta, los edificios de la zona puesto son solo almacenes con baja emisiones. 





### Mapa estudio contaminaci√≥n-CO2

```{r , echo=FALSE}
# Estructura inicial de la app con pesta√±as para analizar contaminantes por regi√≥n
library(shiny)
library(leaflet)
library(sf)
library(dplyr)
library(ggplot2)
library(RColorBrewer)

# Cargar dataset de calidad del aire
contaminantes_df <- read.csv("Calidad_Aire_limpio.csv")
contaminantes_df$FechaHora <- as.POSIXct(contaminantes_df$FechaHora, format="%Y-%m-%d %H:%M:%S")

# UI
ui <- navbarPage("Mapa interactivo de contaminantes",

  tabPanel("Mapa de calor por contaminante",
    sidebarLayout(
      sidebarPanel(
        selectInput("contaminante", "Selecciona contaminante:",
                    choices = c("NO", "NO2", "NOx", "O3", "PM10", "PM2.5", "SO2")),
        helpText("Muestra la media total del contaminante por regi√≥n Voronoi.")
      ),
      mainPanel(
        leafletOutput("mapa_calor", height = "800px")
      )
    )
  )
)

# SERVER
server <- function(input, output, session) {

  # C√°lculo de suma anual del contaminante seleccionado por zona
  datos_anuales <- reactive({
    req(input$contaminante)
    contaminantes_df %>%
      filter(format(FechaHora, "%Y") == "2023") %>%
      group_by(Origen) %>%
      summarise(valor_total = sum(.data[[input$contaminante]], na.rm = TRUE))
  })

  # Render del mapa de calor
  output$mapa_calor <- renderLeaflet({
    datos <- datos_anuales()
    mapa <- left_join(voronoi_sf, datos, by = c("nombre" = "Origen"))
    paleta <- colorNumeric("YlOrRd", domain = mapa$valor_total)

    leaflet() %>%
      addTiles() %>%
      addPolygons(
        data = mapa,
        fillColor = ~paleta(valor_total),
        color = "black",
        weight = 1,
        fillOpacity = 0.7,
        label = ~paste0(nombre, ": ", round(valor_total, 1)),
        highlightOptions = highlightOptions(weight = 3, fillOpacity = 0.9)
      ) %>%
      addLegend("bottomright", pal = paleta, values = mapa$valor_total,
                title = paste("Suma 2023 -", input$contaminante),
                opacity = 1)
  })
}

# EJECUCI√ìN
shinyApp(ui, server)


```

```{r , echo=FALSE}
head(data_parcelas,10)
```

Al comparar con los certificados energ√©ticos podemos observar discrepancias pero tienen sentido , de los cee solo hay de los diferentes edificios mientras que los sensores de contaminaci√≥n miden el valor que hay en el aire en un momento dado, el co2 de los diferentes inmuebles se emite debido al uso de aparatos de refiregereacion y climatizaci√≥n, calentar el agua, cocinar por lo que los niveles m√°s altos ser√°n de 7-9 de la ma√±ana (para calentar el agua), de 11 a 18 de la tarde en verano(aire acondicionados) y en inviertno de 19 a 23 horas por la calefacci√≥n. 

Las emisiones de NO son superiores en la zona del puerto seguramente por las emisiones de los barcos, sin embargo edificio apenas emiten co2 pq no hay muchos por esta zona del casco antiguo si es una de los prinicpales emisoras de este gas y tambien de las zonas que m√°s emiten co2 en la ciudad 


Respecto al no2 vemos que es m√°s emitido en feneral en toda la ciudad el puesto ya est√° solo, vemos zpoonas industriales como paterna y el casco por lo que podria tener relaci¬¥pon con el co2



El o3 si que tiene un gran peso en Valenica excepto en la parte del puerto bajo. 

El PM10 destaca en paterna , industias 

# Calcular la matriz de dcorrelaciones person

```{r , echo=FALSE}
library(dplyr)
library(ggplot2)

# 1. Emisiones totales por zona desde edificios
emisiones_zona <- data_parcelas %>%
  mutate(emisiones = EMISIONES_CO2_VALOR * SUPERFICIE_M2) %>%
  group_by(sensor_cercano) %>%
  summarise(total_CO2 = sum(emisiones, na.rm = TRUE))

# 2. Medias anuales de contaminantes por zona
contaminantes_medias <- contaminantes_df %>%
  filter(format(FechaHora, "%Y") == "2023") %>%
  group_by(Origen) %>%
  summarise(across(c(NO, NO2, NOx, O3, PM10, PM2.5, SO2), mean, na.rm = TRUE)) %>%
  rename(sensor_cercano = Origen)

# 3. Unir ambas (solo zonas con ambos datos)
zonas_completas <- inner_join(emisiones_zona, contaminantes_medias, by = "sensor_cercano")

# 4. Calcular correlaciones entre total_CO2 y cada contaminante
correlaciones <- sapply(names(zonas_completas)[-c(1, 2)], function(cont) {
  cor(zonas_completas$total_CO2, zonas_completas[[cont]], use = "complete.obs")
})

# 5. Mostrar como tabla
cor_df <- data.frame(
  Contaminante = names(correlaciones),
  Pearson = round(correlaciones, 3)
)

print(cor_df)

# 6. Gr√°fico de barras
ggplot(cor_df, aes(x = Contaminante, y = Pearson)) +
  geom_col(fill = "darkorange") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  ylim(-1, 1) +
  labs(title = "Correlaci√≥n entre emisiones de CO‚ÇÇ y contaminantes (por zonas)",
       y = "Coeficiente de Pearson", x = "Contaminante") +
  theme_minimal()



```
NO, NO2, NOx, PM10, PM2.5, SO2 ‚Üí Tienen correlaci√≥n negativa o casi nula con CO‚ÇÇ ‚Üí en zonas con m√°s CO‚ÇÇ (edificios grandes), no hay necesariamente m√°s contaminantes. Puede ser que sean zonas m√°s perif√©ricas o industriales con menos densidad urbana.

El CO‚ÇÇ no genera O‚ÇÉ directamente, pero al contribuir al calentamiento y a la intensidad de la radiaci√≥n UV, favorece las condiciones en las que el ozono troposf√©rico se forma y acumula, especialmente en entornos urbanos soleados.


# An√°lisis contamianntes medias horarias verano e invierno

```{r , echo=FALSE}
library(dplyr)
library(ggplot2)
library(tidyr)

# Aseg√∫rate del formato de fecha
contaminantes_df$FechaHora <- as.POSIXct(contaminantes_df$FechaHora, format = "%Y-%m-%d %H:%M:%S")

# Crear carpeta si no existe
if (!dir.exists("graficas_estacionales")) {
  dir.create("graficas_estacionales")
}

# Listado de zonas
zonas_validas <- unique(na.omit(contaminantes_df$Origen))

for (zona in zonas_validas) {
  df_zona <- contaminantes_df %>%
    filter(Origen == zona) %>%
    mutate(
      Mes = as.numeric(format(FechaHora, "%m")),
      Hora = as.numeric(format(FechaHora, "%H")),
      Estacion = case_when(
        Mes %in% c(6, 7, 8, 9) ~ "Verano",
        Mes %in% c(11, 12, 1, 2) ~ "Invierno",
        TRUE ~ NA_character_
      )
    ) %>%
    filter(!is.na(Estacion))

  if (nrow(df_zona) < 50) next  # Saltar si hay pocos datos

  # Calcular medias por hora y estaci√≥n
  medias_horarias <- df_zona %>%
    group_by(Estacion, Hora) %>%
    summarise(across(c(NO, NO2, NOx, O3, PM10, PM2.5, SO2), mean, na.rm = TRUE), .groups = "drop") %>%
    pivot_longer(-c(Estacion, Hora), names_to = "Contaminante", values_to = "Valor")

  for (est in c("Verano", "Invierno")) {
    df_plot <- medias_horarias %>% filter(Estacion == est)

    if (nrow(df_plot) == 0) next

    g <- ggplot(df_plot, aes(x = Hora, y = Valor, color = Contaminante)) +
      geom_line(size = 1.2) +
      labs(
        title = paste("Patr√≥n horario -", est, "-", zona),
        x = "Hora del d√≠a",
        y = "Concentraci√≥n media (¬µg/m¬≥)"
      ) +
      theme_minimal() +
      scale_x_continuous(breaks = 0:23) +
      theme(legend.position = "bottom")

    print(g)

    ggsave(
      filename = paste0("graficas_estacionales/", gsub(" ", "_", zona), "_", est, ".png"),
      plot = g, width = 10, height = 6
    )
  }
}



```



```






