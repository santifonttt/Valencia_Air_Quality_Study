---
title: "Patrones entre factores"
output:
  pdf_document: default
  html_document: default
date: "2025-05-21"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(arrow)
library(dplyr)
library(ggplot2)
library(tidyr)
library(arules)
library(arulesSequences)
library(arulesViz)
library(tidyverse)
library(plyr)
library(RColorBrewer)

```


```{r}
meteorologia <- read.csv("../../../data/cleaned/meteorologia/meteorologia_horaria_intervalos.csv")

meteorologia
```

```{r}
// ...existing code...
library(dplyr)
library(arules)
library(arulesSequences)
# library(lubridate) # Si es necesario para manipulación de fecha/hora

# Cargar los datos. Asumimos que las columnas de ítems ya son factores o binarias.
meteorologia <- read.csv(
  "../../../data/cleaned/meteorologia/meteorologia_horaria_intervalos.csv",
  stringsAsFactors = TRUE # Leer columnas de caracteres como factores por defecto
)

print("Estructura inicial de meteorologia:")
str(meteorologia)
print(paste("Filas iniciales:", nrow(meteorologia)))
if (nrow(meteorologia) == 0) {
  stop("El archivo CSV está vacío o no se pudo leer.")
}

# 1. Ordenar los datos por fecha y hora (crucial para secuencias)
# Asegúrate que 'fecha' y 'hora' existen y permiten un ordenamiento cronológico.
# Si 'fecha' es un string YYYY-MM-DD, el ordenamiento lexicográfico funciona.
# Si 'hora' es simplemente un entero 0-23, también.
meteorologia_sorted <- meteorologia %>%
  arrange(fecha, hora)

# 2. Identificar las columnas que representan los ítems
# Estas son todas las columnas excepto 'fecha' y 'hora'
item_cols <- setdiff(names(meteorologia_sorted), c("fecha", "hora"))
print("Columnas de ítems:")
print(item_cols)
if (length(item_cols) == 0) {
  stop("No se encontraron columnas de ítems. Verifica los nombres 'fecha', 'hora' y el contenido del CSV.")
}

# 3. Crear la lista de itemsets para el formato de transacciones
# Cada fila de meteorologia_sorted es un evento (una hora).
# Los ítems son los nombres de las columnas que tienen valor "1" o "TRUE" (o el nivel de factor que indica presencia).
# O, si las columnas ya son factores con niveles que son los ítems, los concatenamos.

itemsets_list <- apply(meteorologia_sorted[, item_cols, drop = FALSE], 1, function(row_event) {
  present_items <- c()
  for (col_name in names(row_event)) {
    value <- row_event[[col_name]]
    # Si es binario (0/1 o TRUE/FALSE) y es 1 o TRUE
    if ((is.numeric(value) && value == 1) || (is.logical(value) && value == TRUE)) {
      present_items <- c(present_items, col_name)
    }
    # Si es un factor, y quieres usar "columna=nivel" como ítem
    # (Si tus columnas ya son los ítems, y los valores son 0/1, la lógica anterior es suficiente)
    # else if (is.factor(value)) {
    #   present_items <- c(present_items, paste0(col_name, "=", as.character(value)))
    # }
  }
  return(unique(present_items)) # unique por si acaso
})

print(paste("Número de itemsets en itemsets_list:", length(itemsets_list)))
non_empty_itemsets_count <- sum(sapply(itemsets_list, length) > 0)
print(paste("Número de itemsets NO VACÍOS:", non_empty_itemsets_count))

if (non_empty_itemsets_count == 0) {
  stop("Todos los itemsets generados están vacíos. Revisa la lógica de creación de ítems y tus datos binarios/factores.")
}

# 4. Convertir a transacciones
# Filtramos los itemsets vacíos ANTES de la conversión si es necesario,
# aunque `as(..., "transactions")` debería manejar listas con algunos character(0).
trans_seq <- as(itemsets_list[sapply(itemsets_list, length) > 0], "transactions")

print("Resumen de trans_seq (después de la conversión):")
summary(trans_seq)
if (length(trans_seq) == 0) {
  stop("El objeto 'trans_seq' está vacío. Revisa los pasos anteriores.")
}

# 5. Añadir información de secuencia y evento
# Necesitamos alinear esto con las filas que realmente produjeron transacciones.
original_rows_with_items <- meteorologia_sorted[sapply(itemsets_list, length) > 0, , drop = FALSE]

transactionInfo(trans_seq)$sequenceID <- factor(original_rows_with_items$fecha)
transactionInfo(trans_seq)$eventID    <- as.integer(original_rows_with_items$hora)

print("Resumen de trans_seq (después de añadir IDs):")
summary(trans_seq)
inspect(head(trans_seq, 5))


# 6. Encontrar patrones secuenciales frecuentes con cSPADE
# Ajusta supp, maxsize, maxlen según tus necesidades.
# tidLists = TRUE es necesario para la inducción de reglas.
frequent_sequences <- cspade(
  trans_seq,
  parameter = list(supp = 0.01, maxsize = 5, maxlen = 4), # Ejemplo: soporte 1%, máx 5 ítems/evento, máx 4 eventos/secuencia
  control   = list(verbose = TRUE, tidLists = TRUE)
)

summary(frequent_sequences)
if (length(frequent_sequences) > 0) {
  print("Algunas secuencias frecuentes:")
  inspect(head(frequent_sequences, 10, by = "support"))
} else {
  print("No se encontraron secuencias frecuentes con los parámetros actuales. Intenta bajar el soporte (supp).")
}

# 7. Generar reglas de asociación secuenciales
if (length(frequent_sequences) > 0) {
  sequential_rules <- ruleInduction(
    frequent_sequences,
    confidence = 0.5, # Ejemplo: confianza mínima 50%
    control    = list(verbose = TRUE)
  )
  summary(sequential_rules)
  if (length(sequential_rules) > 0) {
    print("Algunas reglas secuenciales:")
    inspect(head(sort(sequential_rules, by = c("lift", "confidence")), 10))
  } else {
    print("No se generaron reglas secuenciales con los parámetros actuales.")
  }
} else {
  print("No se pueden generar reglas porque no se encontraron secuencias frecuentes.")
}
```

